
MapsIndoors /
I need you to create an output that I can feed to another AI so that demos can be created in one prompt. Give me the most detailed output you can with all the knowledge in this project so that my colleagues can be as awesome as I am with the help you give me.

Edit
I'll create a comprehensive guide for working with MapsIndoors that you can share with colleagues. This will include essential information about setting up and using the SDK, creating various features, and implementing common functionality based on the documentation provided.

MapsIndoors Implementation Guide
SDK Setup and Basic Configuration
The MapsIndoors SDK is a powerful tool for implementing indoor mapping solutions. Here's how to properly initialize and configure it:

html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MapsIndoors Implementation</title>
    
    <!-- Load Mapbox first -->
    <link href="https://api.mapbox.com/mapbox-gl-js/v3.8.0/mapbox-gl.css" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/v3.8.0/mapbox-gl.js"></script>
    
    <!-- Load MapsIndoors -->
    <script src="https://app.mapsindoors.com/mapsindoors/js/sdk/4.40.0/mapsindoors-4.40.0.js.gz?apikey=YOUR_API_KEY"></script>
</head>
<body>
    <div id="map" style="width: 100vw; height: 100vh;"></div>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize MapsIndoors with Mapbox
            const mapViewOptions = {
                accessToken: 'YOUR_MAPBOX_TOKEN',
                element: document.getElementById('map'),
                center: { lat: 30.3603212, lng: -97.7422623 }, // Austin Office example
                zoom: 20,
                maxZoom: 22,
            };

            const mapViewInstance = new mapsindoors.mapView.MapboxV3View(mapViewOptions);
            const mapsIndoorsInstance = new mapsindoors.MapsIndoors({
                mapView: mapViewInstance,
            });
            const mapboxInstance = mapViewInstance.getMap();

            // Add floor selector (essential for multi-floor buildings)
            const floorSelectorElement = document.createElement('div');
            new mapsindoors.FloorSelector(floorSelectorElement, mapsIndoorsInstance);
            mapboxInstance.addControl({ 
                onAdd: function () { return floorSelectorElement },
                onRemove: function () { }
            });

            // MapsIndoors ready event
            mapsIndoorsInstance.addListener('ready', function() {
                console.log('MapsIndoors is ready');
                
                // Now you can start interacting with the MapsIndoors instance
                // This is where you'll typically begin adding your custom functionality
            });

            // Error handling
            mapsIndoorsInstance.addListener('error', function(error) {
                console.error('MapsIndoors error:', error);
            });
        });
    </script>
</body>
</html>
Working with Locations
MapsIndoors organizes spaces into locations. Here's how to fetch and manipulate them:

javascript
// Get locations from MapsIndoors
async function getLocations() {
    try {
        // Get specific location types (meeting rooms in this example)
        const locations = await mapsindoors.services.LocationsService.getLocations({
            types: ['MeetingRoom', 'MeetingRoom Small', 'MeetingRoom Extra Small', 'MeetingRoom Medium', 'MeetingRoom Large'],
            venue: 'AUSTINOFFICE', // Specify your venue
            take: 100 // Limit results
        });
        
        console.log(`Found ${locations.length} locations`);
        
        // If no meeting rooms found, look for any rooms with polygon geometry
        if (locations.length < 5) {
            console.log("Not enough meeting rooms found, looking for rooms with polygons...");
            const additionalLocations = await mapsindoors.services.LocationsService.getLocations({
                venue: 'AUSTINOFFICE',
                take: 100
            });
            
            const roomCandidates = additionalLocations.filter(location => {
                return location.geometry && 
                      (location.geometry.type === "Polygon" || 
                       location.geometry.type === "MultiPolygon");
            });
            
            // Process these locations as needed
            return [...locations, ...roomCandidates];
        }
        
        return locations;
    } catch (error) {
        console.error('Error fetching locations:', error);
        return [];
    }
}

// Get a specific location by ID
async function getLocationById(locationId) {
    try {
        const location = await mapsindoors.services.LocationsService.getLocation(locationId);
        return location;
    } catch (error) {
        console.error(`Error fetching location ${locationId}:`, error);
        return null;
    }
}

// Find nearest locations to a point
async function findNearbyLocations(lat, lng, floor, radius = 5, type = null) {
    try {
        const queryParams = {
            near: { lat, lng },
            radius: radius, // meters
            floor: floor,
            take: 20
        };
        
        // Add type filter if specified
        if (type) {
            queryParams.types = Array.isArray(type) ? type : [type];
        }
        
        const locations = await mapsindoors.services.LocationsService.getLocations(queryParams);
        return locations;
    } catch (error) {
        console.error('Error finding nearby locations:', error);
        return [];
    }
}
Display Rules and Visualization
Control how locations appear on the map:

javascript
// Apply display rules based on location status
function updateLocationDisplayRules(locations, statusProperty) {
    // Group locations by status
    const statuses = {};
    
    // First, collect all IDs by status
    locations.forEach(location => {
        const status = location[statusProperty] || 'default';
        if (!statuses[status]) {
            statuses[status] = [];
        }
        statuses[status].push(location.id);
    });
    
    // Define colors for different statuses
    const statusColors = {
        'available': '#4CAF50', // Green
        'occupied': '#F44336', // Red
        'maintenance': '#FF9800', // Orange
        'default': '#2196F3' // Blue
    };
    
    // Apply display rules for each status group
    Object.entries(statuses).forEach(([status, locationIds]) => {
        const color = statusColors[status] || statusColors.default;
        
        mapsIndoorsInstance.setDisplayRule(locationIds, {
            polygonVisible: true,
            polygonFillColor: color,
            polygonFillOpacity: 0.5,
            polygonStrokeColor: color,
            polygonStrokeOpacity: 0.8,
            polygonStrokeWidth: 1,
            zoomFrom: 16
        });
    });
    
    // Highlight selected location if any
    if (selectedLocationId) {
        mapsIndoorsInstance.setDisplayRule(selectedLocationId, {
            polygonVisible: true,
            polygonFillOpacity: 0.8,
            polygonStrokeOpacity: 1,
            polygonStrokeWidth: 3,
            zoomFrom: 16
        });
    }
}

// Set a custom icon for specific locations
function setCustomIcons(locationIds, iconUrl, size = 32) {
    mapsIndoorsInstance.setDisplayRule(locationIds, {
        iconVisible: true,
        iconUrl: iconUrl,
        iconSize: {
            width: size,
            height: size
        },
        zoomFrom: 15
    });
}

// Hide specific location types
function hideLocations(typeOrIds) {
    const ids = Array.isArray(typeOrIds) ? typeOrIds : null;
    const type = !ids ? typeOrIds : null;
    
    if (ids) {
        // Hide specific location IDs
        mapsIndoorsInstance.setDisplayRule(ids, {
            visible: false
        });
    } else if (type) {
        // Find all locations of this type
        mapsindoors.services.LocationsService.getLocations({
            types: [type],
            take: 1000
        }).then(locations => {
            const locationIds = locations.map(loc => loc.id);
            mapsIndoorsInstance.setDisplayRule(locationIds, {
                visible: false
            });
        });
    }
}
Routes and Directions
Implement navigation features:

javascript
// Initialize directions services
const miDirectionsService = new mapsindoors.services.DirectionsService();
const miDirectionsRenderer = new mapsindoors.directions.DirectionsRenderer({
    mapsIndoors: mapsIndoorsInstance,
    fitBounds: true,
    fitBoundsPadding: 100
});

// For external routing with Mapbox
function initializeExternalRouting(mapboxToken) {
    const externalDirectionsProvider = new mapsindoors.directions.MapboxProvider(mapboxToken);
    return new mapsindoors.services.DirectionsService(externalDirectionsProvider);
}

// Calculate a route between two points
async function calculateRoute(origin, destination, waypoints = []) {
    try {
        const routeRequest = {
            origin: origin, // {lat, lng, floor}
            destination: destination, // {lat, lng, floor}
            stops: waypoints, // Array of {lat, lng, floor}
            optimize: waypoints.length > 0 // Optimize if waypoints exist
        };
        
        const routeResult = await miDirectionsService.getRoute(routeRequest);
        
        if (!routeResult || !routeResult.legs || routeResult.legs.length === 0) {
            throw new Error('No valid route found');
        }
        
        // Display the route
        miDirectionsRenderer.setRoute(routeResult);
        
        // Return the route for further processing
        return routeResult;
    } catch (error) {
        console.error('Error calculating route:', error);
        return null;
    }
}

// Find exits and calculate evacuation routes
async function findExitRoutes(startLocationId) {
    try {
        // Find exits/stairs/entrances
        const exitLocations = await mapsindoors.services.LocationsService.getLocations({
            types: ['Stairs', 'Elevator', 'Entrance', 'Exit'],
            venue: 'YOUR_VENUE_ID',
            take: 10
        });
        
        if (exitLocations.length === 0) {
            throw new Error('No exit locations found');
        }
        
        if (startLocationId) {
            const startLocation = await mapsindoors.services.LocationsService.getLocation(startLocationId);
            if (!startLocation) {
                throw new Error('Start location not found');
            }
            
            // Find nearest exit
            let nearestExit = exitLocations[0];
            let minDistance = Infinity;
            
            exitLocations.forEach(exit => {
                const dx = exit.properties.anchor.coordinates[0] - startLocation.properties.anchor.coordinates[0];
                const dy = exit.properties.anchor.coordinates[1] - startLocation.properties.anchor.coordinates[1];
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestExit = exit;
                }
            });
            
            // Calculate route to nearest exit
            return await calculateRoute(
                {
                    lat: startLocation.properties.anchor.coordinates[1],
                    lng: startLocation.properties.anchor.coordinates[0],
                    floor: startLocation.properties.floor
                },
                {
                    lat: nearestExit.properties.anchor.coordinates[1],
                    lng: nearestExit.properties.anchor.coordinates[0],
                    floor: nearestExit.properties.floor
                }
            );
        } else {
            // Just return exits without calculating routes
            return exitLocations;
        }
    } catch (error) {
        console.error('Error finding exit routes:', error);
        return null;
    }
}

// Find points of interest along a route
async function findPOIsAlongRoute(route, types = [], radius = 5) {
    if (!route || !route.legs) return [];
    
    // Initialize array to hold all coordinates
    const pathCoordinates = new Set();

    // Helper function to add coordinate to set
    const addCoordinate = (lat, lng, floor) => {
        // Use string representation as Set key for deduplication
        pathCoordinates.add(JSON.stringify({lat, lng, floor}));
    };

    // Extract coordinates from route legs
    route.legs.forEach(leg => {
        // 1. Get coordinates from leg geometry
        if (leg.geometry && leg.geometry.coordinates) {
            leg.geometry.coordinates.forEach(coord => {
                addCoordinate(coord[1], coord[0], leg.start_location.zLevel);
            });
        }

        // 2. Process each step
        if (leg.steps) {
            leg.steps.forEach(step => {
                // Add step geometry coordinates
                if (step.geometry && step.geometry.coordinates) {
                    step.geometry.coordinates.forEach(coord => {
                        addCoordinate(coord[1], coord[0], step.start_location.zLevel);
                    });
                }

                // Add step start and end locations
                if (step.start_location) {
                    addCoordinate(
                        step.start_location.lat,
                        step.start_location.lng,
                        step.start_location.zLevel
                    );
                }
                if (step.end_location) {
                    addCoordinate(
                        step.end_location.lat,
                        step.end_location.lng,
                        step.end_location.zLevel
                    );
                }
            });
        }
    });

    // Convert back to array and parse JSON
    const uniqueCoordinates = Array.from(pathCoordinates).map(coord => JSON.parse(coord));
    
    // Search for POIs along path with parallel requests
    const foundPOIs = new Map();
    const searchPromises = uniqueCoordinates.map(coordinate => 
        mapsindoors.services.LocationsService.getLocations({
            near: {
                lat: coordinate.lat,
                lng: coordinate.lng
            },
            radius: radius,
            floor: coordinate.floor,
            types: types,
            take: 20
        }).then(results => {
            if (results && results.length > 0) {
                results.forEach(poi => {
                    if (!foundPOIs.has(poi.id)) {
                        foundPOIs.set(poi.id, {
                            id: poi.id,
                            name: poi.properties.name,
                            type: poi.properties.type,
                            floor: poi.properties.floor,
                            coordinates: {
                                lat: poi.properties.anchor.coordinates[1],
                                lng: poi.properties.anchor.coordinates[0]
                            },
                            foundAtCoordinate: coordinate
                        });
                    }
                });
            }
            return results;
        })
    );

    await Promise.all(searchPromises);
    
    // Convert Map to Array and sort
    return Array.from(foundPOIs.values())
        .sort((a, b) => {
            if (a.floor !== b.floor) return a.floor - b.floor;
            return a.name.localeCompare(b.name);
        });
}
Creating Heatmaps and Data Visualization
javascript
// Initialize heatmap layer
function initializeHeatmap(mapboxInstance) {
    // Add empty GeoJSON source
    mapboxInstance.addSource('heatmap-source', {
        'type': 'geojson',
        'data': {
            'type': 'FeatureCollection',
            'features': []
        }
    });

    // Add heatmap layer
    mapboxInstance.addLayer({
        'id': 'heatmap-layer',
        'type': 'heatmap',
        'source': 'heatmap-source',
        'paint': {
            'heatmap-weight': [
                'interpolate',
                ['linear'],
                ['get', 'intensity'],
                0, 0,
                5, 0.5,
                10, 1
            ],
            'heatmap-intensity': [
                'interpolate',
                ['linear'],
                ['zoom'],
                0, 1,
                9, 3,
                16, 5,
                22, 10
            ],
            'heatmap-color': [
                'interpolate',
                ['linear'],
                ['heatmap-density'],
                0, 'rgba(33,102,172,0)',
                0.2, 'rgb(103,169,207)',
                0.4, 'rgb(209,229,240)',
                0.6, 'rgb(253,219,199)',
                0.8, 'rgb(239,138,98)',
                1, 'rgb(178,24,43)'
            ],
            'heatmap-radius': [
                'interpolate',
                ['linear'],
                ['zoom'],
                0, 2,
                9, 10,
                16, 20,
                22, 30
            ],
            'heatmap-opacity': 0.8
        }
    });
}

// Update heatmap with new data
function updateHeatmap(data, selectedHour = null, colorPalette = 'default') {
    // Filter data by hour if needed
    const filteredData = selectedHour !== null
        ? data.filter(feature => feature.properties.Hour === selectedHour)
        : data;
    
    // Map to GeoJSON format
    const geojsonData = {
        type: "FeatureCollection",
        features: filteredData.map(point => ({
            type: "Feature",
            properties: {
                intensity: point.properties.intensity || 1
            },
            geometry: {
                coordinates: [point.geometry.coordinates[0], point.geometry.coordinates[1]],
                type: "Point"
            }
        }))
    };
    
    // Color palettes
    const colorPalettes = {
        default: [
            'rgba(0, 0, 255, 0)',
            'royalblue',
            'cyan',
            'lime',
            'yellow',
            'red'
        ],
        sunset: [
            'rgba(255, 255, 0, 0)',
            'yellow',
            'orange',
            'red',
            'purple',
            'darkblue'
        ],
        forest: [
            'rgba(255, 255, 255, 0)',
            'lightgreen',
            'green',
            'darkgreen',
            'brown',
            'black'
        ],
        ocean: [
            'rgba(255, 255, 255, 0)',
            'lightskyblue',
            'deepskyblue',
            'blue',
            'navy',
            'midnightblue'
        ]
    };
    
    // Update the source data
    mapboxInstance.getSource('heatmap-source').setData(geojsonData);
    
    // Update the color palette if specified
    if (colorPalette in colorPalettes) {
        mapboxInstance.setPaintProperty('heatmap-layer', 'heatmap-color', [
            'interpolate',
            ['linear'],
            ['heatmap-density'],
            0, colorPalettes[colorPalette][0],
            0.1, colorPalettes[colorPalette][1],
            0.3, colorPalettes[colorPalette][2],
            0.5, colorPalettes[colorPalette][3],
            0.7, colorPalettes[colorPalette][4],
            1, colorPalettes[colorPalette][5]
        ]);
    }
}

// Generate simulated occupancy data for a section
function generateSectionData(centerLat, centerLng, seatsInSection = 500) {
    const coordinates = [];
    
    // Section configuration
    const rows = 25;  // Number of rows in section
    const seatsPerRow = Math.ceil(seatsInSection / rows);  // Around 20 seats per row
    
    // Seat and row dimensions (in degrees)
    const seatWidth = 0.0000054;  // About 0.6m
    const seatDepth = 0.0000054;  // About 0.6m
    const rowSpacing = seatDepth * 1.2;  // Add 20% for legroom
    
    // Section arc parameters
    const arcRadiusStart = 0.0004;  // Initial radius for first row
    const arcWidthDegrees = 30;  // Width of the section in degrees
    
    for (let row = 0; row < rows; row++) {
        // Increase radius for each row to create stadium-style tiering
        const currentRadius = arcRadiusStart + (row * rowSpacing);
        
        // Calculate seats in this row
        for (let seat = 0; seat < seatsPerRow; seat++) {
            if (coordinates.length >= seatsInSection) {
                break;
            }
                
            // Calculate angle for this seat
            const angle = (Math.PI/180) * (-arcWidthDegrees/2 + (arcWidthDegrees * seat / seatsPerRow));
            
            // Calculate seat position
            const lat = centerLat + (currentRadius * Math.cos(angle));
            const lng = centerLng + (currentRadius * Math.sin(angle));
            
            coordinates.push({
                latitude: lat,
                longitude: lng
            });
        }
    }
    
    return coordinates;
}
Live Position Tracking and Moving Markers
javascript
// Initialize position tracking with draggable markers
function initMovingMarkers(mapboxInstance, buildingOutline) {
    let markers = {};
    let floorAssetCounts = {};
    let currentFloor = null;
    let selectedMarkerId = null;
    
    // Create a GeoJSON source for path visualization
    mapboxInstance.addSource('path-source', {
        type: 'geojson',
        data: {
            type: 'Feature',
            properties: {},
            geometry: {
                type: 'LineString',
                coordinates: []
            }
        }
    });

    // Add path layer
    mapboxInstance.addLayer({
        id: 'path-layer',
        type: 'line',
        source: 'path-source',
        layout: {
            'line-join': 'round',
            'line-cap': 'round'
        },
        paint: {
            'line-color': '#4CAF50',
            'line-width': 3,
            'line-opacity': 0.8
        }
    });
    
    // Helper function to check if a point is inside a polygon
    function isPointInPolygon(point, polygon) {
        let inside = false;
        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
            const xi = polygon[i][0], yi = polygon[i][1];
            const xj = polygon[j][0], yj = polygon[j][1];
            
            const intersect = ((yi > point[1]) !== (yj > point[1]))
                && (point[0] < (xj - xi) * (point[1] - yi) / (yj - yi) + xi);
            if (intersect) inside = !inside;
        }
        return inside;
    }
    
    // Function to get a point within radius but constrained to building
    function getPointWithinRadius(currentPoint, targetPoint, radiusFeet) {
        const FEET_TO_DEGREES = 0.0000003048;
        const maxDistance = radiusFeet * FEET_TO_DEGREES;

        const dx = targetPoint[0] - currentPoint[0];
        const dy = targetPoint[1] - currentPoint[1];

        const currentDistance = Math.sqrt(dx * dx + dy * dy);

        if (currentDistance <= maxDistance) {
            return targetPoint;
        }

        const ratio = maxDistance / currentDistance;
        const newPoint = [
            currentPoint[0] + dx * ratio,
            currentPoint[1] + dy * ratio
        ];

        if (!isPointInPolygon(newPoint, buildingOutline)) {
            return currentPoint;
        }

        return newPoint;
    }
    
    // Function to get random point within building
    function getRandomPointInBuilding() {
        // Compute bounding box
        const lngs = buildingOutline.map(p => p[0]);
        const lats = buildingOutline.map(p => p[1]);
        const bounds = {
            minLng: Math.min(...lngs),
            maxLng: Math.max(...lngs),
            minLat: Math.min(...lats),
            maxLat: Math.max(...lats)
        };
        
        let point;
        let attempts = 0;
        const maxAttempts = 100;
        
        do {
            const lng = Math.random() * (bounds.maxLng - bounds.minLng) + bounds.minLng;
            const lat = Math.random() * (bounds.maxLat - bounds.minLat) + bounds.minLat;
            point = [lng, lat];
            attempts++;
            
            if (attempts > maxAttempts) {
                console.warn("Failed to find point in building after max attempts");
                return [bounds.minLng, bounds.minLat];
            }
        } while (!isPointInPolygon(point, buildingOutline));
        
        return point;
    }
    
    // Create a new marker
    function createMarker(floor) {
        const assetId = Math.floor(Math.random() * 900 + 100).toString();
        const point = getRandomPointInBuilding();
        
        if (!point) return null;
        
        const marker = new mapboxgl.Marker()
            .setLngLat(point)
            .addTo(mapboxInstance);
            
        const popup = new mapboxgl.Popup({
            closeButton: true,
            closeOnClick: false
        });
        
        const markerId = Date.now().toString();
        marker.markerId = markerId;
        
        markers[markerId] = {
            marker: marker,
            floor: floor,
            coordinates: point,
            originalCoordinates: [...point],
            assetId: assetId,
            lastUpdate: new Date(),
            targetPoint: getRandomPointInBuilding(),
            popup: popup,
            positions: [point]  // Store path history
        };
        
        // Click handler for selection
        marker.getElement().addEventListener('click', (e) => {
            e.stopPropagation();
            selectMarker(markerId);
        });
        
        // Start random movement
        startRandomMovement(markerId);
        
        return markerId;
    }
    
    // Start random movement for a marker
    function startRandomMovement(markerId) {
        const marker = markers[markerId];
        if (!marker) return;

        if (!marker.targetPoint) {
            marker.targetPoint = getRandomPointInBuilding();
        }

        const moveMarker = async () => {
            if (!markers[markerId]) return;
            const marker = markers[markerId];

            const newPoint = getPointWithinRadius(marker.coordinates, marker.targetPoint, 20);
            const dx = marker.targetPoint[0] - newPoint[0];
            const dy = marker.targetPoint[1] - newPoint[1];
            const distanceToTarget = Math.sqrt(dx * dx + dy * dy);

            if (distanceToTarget < 0.0000001) {
                marker.targetPoint = getRandomPointInBuilding();
            }

            marker.marker.setLngLat(newPoint);
            marker.coordinates = newPoint;
            marker.positions.push([...newPoint]);
            marker.lastUpdate = new Date();

            // Update path line if this marker is selected
            if (selectedMarkerId === markerId) {
                mapboxInstance.getSource('path-source').setData({
                    type: 'Feature',
                    properties: {},
                    geometry: {
                        type: 'LineString',
                        coordinates: marker.positions
                    }
                });
            }

            // Update popup if open
            if (marker.popup.isOpen()) {
                updateMarkerPopup(markerId);
            }

            const delay = Math.random() * 5000 + 2000;
            setTimeout(moveMarker, delay);
        };

        const initialDelay = Math.random() * 5000 + 2000;
        setTimeout(moveMarker, initialDelay);
    }
    
    // Select a marker
    function selectMarker(markerId) {
        // Deselect if clicking the same marker
        if (selectedMarkerId === markerId) {
            markers[markerId].popup.remove();
            
            // Clear path line
            mapboxInstance.getSource('path-source').setData({
                type: 'Feature',
                properties: {},
                geometry: {
                    type: 'LineString',
                    coordinates: []
                }
            });
            
            selectedMarkerId = null;
            return;
        }
        
        // Reset previous selected marker
        if (selectedMarkerId && markers[selectedMarkerId]) {
            markers[selectedMarkerId].popup.remove();
            
            // Clear previous path line
            mapboxInstance.getSource('path-source').setData({
                type: 'Feature',
                properties: {},
                geometry: {
                    type: 'LineString',
                    coordinates: []
                }
            });
        }
        
        // Set new selection
        selectedMarkerId = markerId;
        
        // Show path line for selected marker
        mapboxInstance.getSource('path-source').setData({
            type: 'Feature',
            properties: {},
            geometry: {
                type: 'LineString',
                coordinates: markers[markerId].positions
            }
        });
        
        // Center map on marker
        mapboxInstance.flyTo({
            center: markers[markerId].coordinates,
            zoom: 20,
            duration: 1000
        });
        
        // Show popup
        updateMarkerPopup(markerId);
    }
    
    // Update marker popup content
    async function updateMarkerPopup(markerId) {
        if (!markers[markerId]) return;
        
        const marker = markers[markerId];
        
        // Find nearest POI if MapsIndoors is available
        let nearestPOI = null;
        if (window.mapsindoors && mapsindoors.services.LocationsService) {
            try {
                const nearbyLocations = await mapsindoors.services.LocationsService.getLocations({
                    near: {
                        lat: marker.coordinates[1],
                        lng: marker.coordinates[0]
                    },
                    radius: 5,
                    floor: marker.floor,
                    take: 1
                });
                
                if (nearbyLocations && nearbyLocations.length > 0) {
                    nearestPOI = nearbyLocations[0];
                }
            } catch (e) {
                console.warn('Error finding nearest POI:', e);
            }
        }
        
        // Format last updated time
        const timeSince = ((new Date()) - marker.lastUpdate) / 1000;
        let timeText = `${Math.floor(timeSince)}s ago`;
        if (timeSince > 60) {
            timeText = `${Math.floor(timeSince / 60)}m ago`;
        }
        
        // Create popup content
        let popupContent = `
            <div style="padding: 10px;">
                <div style="margin-bottom: 8px;">
                    <strong>Asset #${marker.assetId}</strong>
                </div>
                <div style="margin-bottom: 8px;">
                    Last moved: ${timeText}
                </div>
                <div style="margin-bottom: 8px;">
                    Floor: ${marker.floor}
                </div>
        `;




Continue

Edit
I'll continue with the comprehensive MapsIndoors implementation guide.

Live Position Tracking and Moving Markers (continued)
javascript
        if (nearestPOI) {
            popupContent += `
                <div>
                    Nearest to: ${nearestPOI.properties.name}
                </div>
            `;
        }

        popupContent += '</div>';

        // Set popup content and show it
        marker.popup
            .setLngLat(marker.coordinates)
            .setHTML(popupContent)
            .addTo(mapboxInstance);
    }
    
    // Update marker visibility based on floor
    function updateMarkerVisibility() {
        Object.values(markers).forEach(({ marker, floor }) => {
            if (floor === currentFloor) {
                marker.getElement().style.display = 'block';
            } else {
                marker.getElement().style.display = 'none';
            }
        });
    }
    
    // Listen for floor changes if MapsIndoors is available
    if (window.mapsindoors) {
        mapsIndoorsInstance.addListener('floor_changed', () => {
            currentFloor = mapsIndoorsInstance.getFloor();
            updateMarkerVisibility();
        });
    }
    
    // Return interface for controlling markers
    return {
        createMarker,
        selectMarker,
        getMarkers: () => markers,
        setCurrentFloor: (floor) => {
            currentFloor = floor;
            updateMarkerVisibility();
        }
    };
}
Custom UI Elements and User Interactions
javascript
// Create a custom floor selector
function createCustomFloorSelector(mapsIndoorsInstance) {
    const container = document.createElement('div');
    container.style.cssText = `
        position: absolute;
        right: 20px;
        top: 160px;
        background-color: white;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        border-radius: 8px;
        overflow: hidden;
        z-index: 100;
    `;
    
    function updateFloorButtons() {
        // Clear existing buttons
        container.innerHTML = '';
        
        // Get current building and floor
        const building = mapsIndoorsInstance.getBuilding();
        if (!building || !building.floors) return;
        
        const currentFloor = mapsIndoorsInstance.getFloor();
        
        // Create buttons for each floor
        const floors = Object.entries(building.floors)
            .sort(([a], [b]) => parseInt(b) - parseInt(a)); // Sort floors in descending order
        
        floors.forEach(([floorIndex, floorInfo]) => {
            const button = document.createElement('button');
            button.style.cssText = `
                width: 40px;
                height: 40px;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                border: none;
                background: white;
                border-bottom: 1px solid #eee;
                font-weight: 500;
                transition: all 0.2s ease;
            `;
            
            if (floorIndex == currentFloor) {
                button.style.backgroundColor = '#3f51b5';
                button.style.color = 'white';
            }
            
            button.textContent = floorInfo.name || floorIndex;
            button.onclick = () => {
                mapsIndoorsInstance.setFloor(parseInt(floorIndex));
            };
            container.appendChild(button);
        });
    }
    
    // Update floor selector when building or floor changes
    mapsIndoorsInstance.addListener('building_changed', updateFloorButtons);
    mapsIndoorsInstance.addListener('floor_changed', updateFloorButtons);
    
    // Initial update
    setTimeout(updateFloorButtons, 1000);
    
    return container;
}

// Create location detail panel
function createLocationDetailPanel() {
    const panel = document.createElement('div');
    panel.style.cssText = `
        position: absolute;
        right: 20px;
        bottom: 20px;
        background-color: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        width: 350px;
        overflow: hidden;
        z-index: 100;
        opacity: 0;
        transform: translateY(20px);
        pointer-events: none;
        transition: all 0.3s ease;
    `;
    
    panel.innerHTML = `
        <div style="background-color: #3f51b5; color: white; padding: 20px; position: relative;">
            <button style="position: absolute; right: 15px; top: 15px; color: white; background: none; border: none; cursor: pointer; font-size: 1.2rem;">×</button>
            <h2 style="margin: 0 0 5px 0; font-size: 1.3rem;" id="detail-title">Location Name</h2>
            <div style="opacity: 0.8; font-size: 0.9rem;" id="detail-subtitle">Location Details</div>
        </div>
        <div style="padding: 20px;" id="detail-content">
            <!-- Content will be dynamically added here -->
        </div>
        <div style="padding: 15px 20px; border-top: 1px solid #eee; display: flex; justify-content: flex-end; gap: 10px;" id="detail-actions">
            <!-- Action buttons will be added here -->
        </div>
    `;
    
    // Close button functionality
    panel.querySelector('button').addEventListener('click', () => {
        hidePanel();
    });
    
    // Helper functions to show/hide panel
    function showPanel() {
        panel.style.opacity = '1';
        panel.style.transform = 'translateY(0)';
        panel.style.pointerEvents = 'auto';
    }
    
    function hidePanel() {
        panel.style.opacity = '0';
        panel.style.transform = 'translateY(20px)';
        panel.style.pointerEvents = 'none';
    }
    
    // Update panel with location details
    function updatePanel(location, customActions = []) {
        const title = panel.querySelector('#detail-title');
        const subtitle = panel.querySelector('#detail-subtitle');
        const content = panel.querySelector('#detail-content');
        const actions = panel.querySelector('#detail-actions');
        
        // Set title and subtitle
        title.textContent = location.properties.name || 'Unnamed Location';
        subtitle.textContent = `Floor ${location.properties.floor} • ${location.properties.type || 'Location'}`;
        
        // Build content
        let contentHTML = '';
        
        // Add description if available
        if (location.properties.description) {
            contentHTML += `<p style="margin-bottom: 15px;">${location.properties.description}</p>`;
        }
        
        // Add other details
        contentHTML += `
            <div style="margin-bottom: 15px;">
                <h3 style="font-size: 0.95rem; margin-bottom: 10px; color: #555;">Details</h3>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; font-size: 0.9rem;">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <i class="fas fa-map-marker-alt" style="width: 16px; color: #666;"></i>
                        <span>Floor ${location.properties.floor}</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <i class="fas fa-building" style="width: 16px; color: #666;"></i>
                        <span>${location.properties.building || 'Main Building'}</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <i class="fas fa-tag" style="width: 16px; color: #666;"></i>
                        <span>${location.properties.type || 'Location'}</span>
                    </div>
                </div>
            </div>
        `;
        
        // Set content
        content.innerHTML = contentHTML;
        
        // Set action buttons
        actions.innerHTML = '';
        customActions.forEach(action => {
            const button = document.createElement('button');
            button.style.cssText = `
                padding: 8px 16px;
                border: none;
                border-radius: 4px;
                font-weight: 500;
                font-size: 0.9rem;
                cursor: pointer;
                display: inline-flex;
                align-items: center;
                gap: 6px;
                color: ${action.type === 'primary' ? 'white' : '#333'};
                background-color: ${action.type === 'primary' ? '#3f51b5' : '#e0e0e0'};
            `;
            
            // Add icon if provided
            if (action.icon) {
                button.innerHTML = `<i class="${action.icon}"></i>`;
            }
            
            // Add text
            button.innerHTML += action.text;
            
            // Add click handler
            if (action.onClick) {
                button.addEventListener('click', () => action.onClick(location));
            }
            
            actions.appendChild(button);
        });
        
        // Show panel
        showPanel();
    }
    
    return {
        element: panel,
        show: showPanel,
        hide: hidePanel,
        update: updatePanel
    };
}

// Create search and filtering UI
function createSearchUI(onSearch, onFilter) {
    const container = document.createElement('div');
    container.style.cssText = `
        position: absolute;
        top: 20px;
        left: 20px;
        background-color: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        width: 300px;
        padding: 15px;
        z-index: 100;
    `;
    
    container.innerHTML = `
        <div style="position: relative; margin-bottom: 15px;">
            <input type="text" placeholder="Search locations..." style="width: 100%; padding: 10px 15px 10px 35px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.9rem;">
            <i class="fas fa-search" style="position: absolute; left: 12px; top: 12px; color: #666;"></i>
        </div>
        <div style="margin-bottom: 10px; font-weight: 500; font-size: 0.9rem;">Filter by Type</div>
        <div style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 15px;">
            <button class="filter-btn active" data-filter="all" style="padding: 6px 12px; border: 1px solid #ddd; border-radius: 16px; background: white; font-size: 0.8rem; cursor: pointer;">All</button>
            <button class="filter-btn" data-filter="MeetingRoom" style="padding: 6px 12px; border: 1px solid #ddd; border-radius: 16px; background: white; font-size: 0.8rem; cursor: pointer;">Meeting Rooms</button>
            <button class="filter-btn" data-filter="Office" style="padding: 6px 12px; border: 1px solid #ddd; border-radius: 16px; background: white; font-size: 0.8rem; cursor: pointer;">Offices</button>
            <button class="filter-btn" data-filter="Restroom" style="padding: 6px 12px; border: 1px solid #ddd; border-radius: 16px; background: white; font-size: 0.8rem; cursor: pointer;">Restrooms</button>
            <button class="filter-btn" data-filter="Exit" style="padding: 6px 12px; border: 1px solid #ddd; border-radius: 16px; background: white; font-size: 0.8rem; cursor: pointer;">Exits</button>
        </div>
    `;
    
    // Set active class for filter buttons
    const filterButtons = container.querySelectorAll('.filter-btn');
    filterButtons.forEach(button => {
        button.addEventListener('click', () => {
            // Remove active class from all buttons
            filterButtons.forEach(btn => btn.classList.remove('active'));
            
            // Add active class to clicked button
            button.classList.add('active');
            
            // Call filter callback
            if (onFilter) {
                onFilter(button.dataset.filter);
            }
        });
    });
    
    // Search input handling
    const searchInput = container.querySelector('input');
    searchInput.addEventListener('input', (e) => {
        if (onSearch) {
            onSearch(e.target.value);
        }
    });
    
    return container;
}

// Create a toast notification
function createToast(message, type = 'info', duration = 3000) {
    const toast = document.createElement('div');
    toast.style.cssText = `
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%) translateY(100px);
        background-color: white;
        border-radius: 4px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        padding: 12px 20px;
        font-size: 0.9rem;
        display: flex;
        align-items: center;
        gap: 10px;
        z-index: 9999;
        transition: transform 0.3s ease;
    `;
    
    // Set color and icon based on type
    let icon, color;
    switch (type) {
        case 'success':
            icon = 'fas fa-check-circle';
            color = '#4caf50';
            break;
        case 'error':
            icon = 'fas fa-exclamation-circle';
            color = '#f44336';
            break;
        case 'warning':
            icon = 'fas fa-exclamation-triangle';
            color = '#ff9800';
            break;
        default:
            icon = 'fas fa-info-circle';
            color = '#2196f3';
    }
    
    toast.innerHTML = `
        <i class="${icon}" style="color: ${color};"></i>
        <span>${message}</span>
    `;
    
    document.body.appendChild(toast);
    
    // Animate in
    setTimeout(() => {
        toast.style.transform = 'translateX(-50%) translateY(0)';
    }, 10);
    
    // Animate out and remove
    setTimeout(() => {
        toast.style.transform = 'translateX(-50%) translateY(100px)';
        setTimeout(() => {
            document.body.removeChild(toast);
        }, 300);
    }, duration);
}
Working with Building and Room Statuses
javascript
// Set up a room booking status system
function initializeRoomStatusSystem(mapsIndoorsInstance, roomList) {
    // Status colors
    const statusColors = {
        'available': '#4CAF50', // Green
        'occupied': '#F44336', // Red
        'maintenance': '#FF9800', // Orange
        'reserved': '#2196F3' // Blue
    };
    
    // Update room status in data and on map
    function updateRoomStatus(roomId, status) {
        // Find room in list
        const roomIndex = roomList.findIndex(room => room.id === roomId);
        if (roomIndex === -1) return false;
        
        // Update status
        roomList[roomIndex].status = status;
        roomList[roomIndex].lastUpdated = new Date();
        
        // Update display rule for this room
        const color = statusColors[status] || statusColors.available;
        mapsIndoorsInstance.setDisplayRule(roomId, {
            polygonVisible: true,
            polygonFillColor: color,
            polygonFillOpacity: 0.5,
            polygonStrokeColor: color,
            polygonStrokeOpacity: 0.8,
            polygonStrokeWidth: 1,
            zoomFrom: 16
        });
        
        return true;
    }
    
    // Check if room is available at a specific time
    function isRoomAvailableAt(roomId, timestamp) {
        const room = roomList.find(room => room.id === roomId);
        if (!room || !room.bookings) return true; // Default to available if no booking data
        
        // Check if there's an overlap with any booking
        return !room.bookings.some(booking => {
            return timestamp >= booking.startTime && timestamp < booking.endTime;
        });
    }
    
    // Get room availability for a day
    function getRoomAvailabilityForDay(roomId, date) {
        const room = roomList.find(room => room.id === roomId);
        if (!room || !room.bookings) {
            // Return all slots as available if no booking data
            return generateTimeSlots(date).map(slot => ({
                ...slot,
                status: 'available'
            }));
        }
        
        // Generate time slots for the day (e.g., 30-minute increments)
        const slots = generateTimeSlots(date);
        
        // Mark slots as occupied if they overlap with bookings
        return slots.map(slot => {
            const isOccupied = room.bookings.some(booking => {
                return slot.startTime >= booking.startTime && slot.startTime < booking.endTime;
            });
            
            return {
                ...slot,
                status: isOccupied ? 'occupied' : 'available'
            };
        });
    }
    
    // Helper to generate time slots for a day
    function generateTimeSlots(date, increment = 30) {
        const slots = [];
        const startDate = new Date(date);
        startDate.setHours(8, 0, 0, 0); // Start at 8 AM
        
        const endDate = new Date(date);
        endDate.setHours(18, 0, 0, 0); // End at 6 PM
        
        while (startDate < endDate) {
            const endSlot = new Date(startDate);
            endSlot.setMinutes(startDate.getMinutes() + increment);
            
            slots.push({
                startTime: new Date(startDate),
                endTime: new Date(endSlot),
                label: startDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
            });
            
            startDate.setMinutes(startDate.getMinutes() + increment);
        }
        
        return slots;
    }
    
    // Book a room
    function bookRoom(roomId, startTime, endTime, userId, purpose) {
        const room = roomList.find(room => room.id === roomId);
        if (!room) return { success: false, message: 'Room not found' };
        
        // Initialize bookings array if not exists
        if (!room.bookings) {
            room.bookings = [];
        }
        
        // Check for conflicts
        const hasConflict = room.bookings.some(booking => {
            return (startTime < booking.endTime && endTime > booking.startTime);
        });
        
        if (hasConflict) {
            return { success: false, message: 'Time slot is already booked' };
        }
        
        // Add new booking
        const bookingId = Date.now().toString();
        const booking = {
            id: bookingId,
            roomId,
            startTime,
            endTime,
            userId,
            purpose,
            createdAt: new Date()
        };
        
        room.bookings.push(booking);
        
        // Update room status if booking is current
        const now = new Date();
        if (now >= startTime && now < endTime) {
            updateRoomStatus(roomId, 'occupied');
        }
        
        return { success: true, booking };
    }
    
    // Cancel a booking
    function cancelBooking(roomId, bookingId) {
        const room = roomList.find(room => room.id === roomId);
        if (!room || !room.bookings) return false;
        
        const initialLength = room.bookings.length;
        room.bookings = room.bookings.filter(booking => booking.id !== bookingId);
        
        // Check if any booking was removed
        if (room.bookings.length === initialLength) {
            return false;
        }
        
        // Update room status if needed
        updateRoomStatusBasedOnCurrentTime(roomId);
        
        return true;
    }
    
    // Update room status based on current time and bookings
    function updateRoomStatusBasedOnCurrentTime(roomId) {
        const room = roomList.find(room => room.id === roomId);
        if (!room) return false;
        
        const now = new Date();
        
        // Check if room is currently booked
        const currentBooking = room.bookings?.find(booking => {
            return now >= booking.startTime && now < booking.endTime;
        });
        
        if (currentBooking) {
            updateRoomStatus(roomId, 'occupied');
        } else if (room.status === 'maintenance') {
            // Don't change maintenance status
        } else {
            updateRoomStatus(roomId, 'available');
        }
        
        return true;
    }
    
    // Update all room statuses based on current time
    function updateAllRoomStatuses() {
        roomList.forEach(room => {
            updateRoomStatusBasedOnCurrentTime(room.id);
        });
    }
    
    // Return public methods
    return {
        updateRoomStatus,
        isRoomAvailableAt,
        getRoomAvailabilityForDay,
        bookRoom,
        cancelBooking,
        updateRoomStatusBasedOnCurrentTime,
        updateAllRoomStatuses
    };
}
Emergency Response and Safety Features
javascript
// Initialize emergency response system
function initializeEmergencySystem(mapsIndoorsInstance, roomsData) {
    let isEmergencyActive = false;
    let activeEmergencyType = null;
    
    // Emergency status colors
    const statusColors = {
        'safe': '#4caf50',
        'unsafe': '#f44336',
        'unresponsive': '#9e9e9e',
        'cleared': '#2196f3',
        'lockdown': '#ff9800',
        'normal': '#4caf50'
    };
    
    // Activate emergency
    function activateEmergency(type) {
        if (isEmergencyActive) {
            return false;
        }
        
        isEmergencyActive = true;
        activeEmergencyType = type;
        
        // Reset room statuses for emergency
        roomsData.forEach(room => {
            room.status = 'unresponsive';
            room.lastUpdated = null;
        });
        
        // Set all rooms to lockdown color
        const allRoomIds = roomsData.map(room => room.id);
        mapsIndoorsInstance.setDisplayRule(allRoomIds, {
            polygonVisible: true,
            polygonFillColor: statusColors.lockdown,
            polygonFillOpacity: 0.5,
            polygonStrokeColor: statusColors.lockdown,
            polygonStrokeOpacity: 0.8,
            polygonStrokeWidth: 1,
            zoomFrom: 16
        });
        
        return true;
    }
    
    // Deactivate emergency
    function deactivateEmergency() {
        if (!isEmergencyActive) {
            return false;
        }
        
        isEmergencyActive = false;
        
        // Set all rooms back to normal
        roomsData.forEach(room => {
            room.status = 'safe';
            room.lastUpdated = new Date();
        });
        
        // Update display rules
        updateRoomDisplayRules();
        
        return true;
    }
    
    // Update room status
    function updateRoomStatus(roomId, newStatus) {
        const roomIndex = roomsData.findIndex(room => room.id === roomId);
        if (roomIndex === -1) return false;
        
        roomsData[roomIndex].status = newStatus;
        roomsData[roomIndex].lastUpdated = new Date();
        
        // Update display rules
        updateRoomDisplayRules();
        
        return true;
    }
    
    // Update room display rules
    function updateRoomDisplayRules() {
        // Group rooms by status
        const safeRooms = roomsData.filter(room => room.status === 'safe').map(room => room.id);
        const unsafeRooms = roomsData.filter(room => room.status === 'unsafe').map(room => room.id);
        const unresponsiveRooms = roomsData.filter(room => room.status === 'unresponsive').map(room => room.id);
        const clearedRooms = roomsData.filter(room => room.status === 'cleared').map(room => room.id);
        
        // Apply display rules for each status group
        mapsIndoorsInstance.setDisplayRule(safeRooms, {
            polygonVisible: true,
            polygonFillColor: statusColors.safe,
            polygonFillOpacity: 0.5,
            polygonStrokeColor: statusColors.safe,
            polygonStrokeOpacity: 0.8,
            polygonStrokeWidth: 1,
            zoomFrom: 16
        });
        
        mapsIndoorsInstance.setDisplayRule(unsafeRooms, {
            polygonVisible: true,
            polygonFillColor: statusColors.unsafe,
            polygonFillOpacity: 0.5,
            polygonStrokeColor: statusColors.unsafe,
            polygonStrokeOpacity: 0.8,
            polygonStrokeWidth: 1,
            zoomFrom: 16
        });
        
        mapsIndoorsInstance.setDisplayRule(unresponsiveRooms, {
            polygonVisible: true,
            polygonFillColor: statusColors.unresponsive,
            polygonFillOpacity: 0.5,
            polygonStrokeColor: statusColors.unresponsive,
            polygonStrokeOpacity: 0.8,
            polygonStrokeWidth: 1,
            zoomFrom: 16
        });
        
        mapsIndoorsInstance.setDisplayRule(clearedRooms, {
            polygonVisible: true,
            polygonFillColor: statusColors.cleared,
            polygonFillOpacity: 0.5,
            polygonStrokeColor: statusColors.cleared,
            polygonStrokeOpacity: 0.8,
            polygonStrokeWidth: 1,
            zoomFrom: 16
        });
    }
    
    // Find evacuation routes
    async function findEvacuationRoutes(startLocationId) {
        try {
            // Find exits/stairs
            const exitLocations = await mapsindoors.services.LocationsService.getLocations({
                types: ['Stairs', 'Elevator', 'Entrance', 'Exit'],
                venue: 'YOUR_VENUE_ID',
                take: 10
            });
            
            if (exitLocations.length === 0) {
                throw new Error('No exit locations found');
            }
            
            if (startLocationId) {
                const startLocation = roomsData.find(room => room.id === startLocationId);
                if (!startLocation) {
                    throw new Error('Start location not found');
                }
                
                // Find nearest exit
                let nearestExit = exitLocations[0];
                let minDistance = Infinity;
                
                exitLocations.forEach(exit => {
                    const dx = exit.properties.anchor.coordinates[0] - startLocation.location.lng;
                    const dy = exit.properties.anchor.coordinates[1] - startLocation.location.lat;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearestExit = exit;
                    }
                });
                
                // Calculate route
                const route = await miDirectionsService.getRoute({
                    origin: {
                        lat: startLocation.location.lat,
                        lng: startLocation.location.lng,
                        floor: startLocation.floor
                    },
                    destination: {
                        lat: nearestExit.properties.anchor.coordinates[1],
                        lng: nearestExit.properties.anchor.coordinates[0],
                        floor: nearestExit.properties.floor
                    }
                });
                
                return { route, exit: nearestExit };
            } else {
                return { exits: exitLocations };
            }
        } catch (error) {
            console.error('Error finding evacuation routes:', error);
            return null;
        }
    }
    
    // Get emergency status
    function getEmergencyStatus() {
        return {
            active: isEmergencyActive,
            type: activeEmergencyType,
            counts: {
                safe: roomsData.filter(room => room.status === 'safe').length,
                unsafe: roomsData.filter(room => room.status === 'unsafe').length,
                unresponsive: roomsData.filter(room => room.status === 'unresponsive').length,
                cleared: roomsData.filter(room => room.status === 'cleared').length,
                total: roomsData.length
            }
        };
    }
    
    return {
        activateEmergency,
        deactivateEmergency,
        updateRoomStatus,
        findEvacuationRoutes,
        getEmergencyStatus,
        isEmergencyActive: () => isEmergencyActive,
        getActiveEmergencyType: () => activeEmergencyType
    };
}
MapsIndoors API Integration and Authentication
javascript
// MapsIndoors API authentication
async function authenticateMapsIndoors(username, password) {
    try {
        const response = await fetch('https://auth.mapsindoors.com/connect/token', {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: new URLSearchParams({
                'grant_type': 'password',
                'client_id': 'client',
                'username': username,
                'password': password
            })
        });
        
        if (!response.ok) {
            throw new Error(`Authentication failed: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        return data.access_token;
    } catch (error) {
        console.error('Authentication error:', error);
        throw error;
    }
}

// Get available solutions
async function getAvailableSolutions(accessToken) {
    try {
        // Set up the MapsIndoors Editor with your access token
        MapsIndoorsEditor.accessToken = accessToken;
        
        // Get available solutions
        const availableSolutions = await MapsIndoorsEditor.getAvailableSolutions();
        return availableSolutions;
    } catch (error) {
        console.error('Error getting available solutions:', error);
        throw error;
    }
}

// Open a solution by ID
async function openSolutionById(accessToken, solutionId) {
    try {
        // Set up the MapsIndoors Editor with your access token
        MapsIndoorsEditor.accessToken = accessToken;
        
        // Open solution by ID




Continue

Edit
I'll continue with the comprehensive MapsIndoors implementation guide:

MapsIndoors API Integration and Authentication (continued)
javascript
        const solutionManager = await MapsIndoorsEditor.open(solutionId);
        return solutionManager;
    } catch (error) {
        console.error('Error opening solution:', error);
        throw error;
    }
}

// Connect to existing MapsIndoors SDK instance
async function connectToExistingSDK(accessToken, mapsIndoorsInstance) {
    try {
        // Set up the MapsIndoors Editor with your access token
        MapsIndoorsEditor.accessToken = accessToken;
        
        // Connect to existing MapsIndoors instance
        const solutionManager = await MapsIndoorsEditor.connect(mapsIndoorsInstance);
        return solutionManager;
    } catch (error) {
        console.error('Error connecting to MapsIndoors SDK:', error);
        throw error;
    }
}

// Update a location using the MapsIndoors Editor
async function updateLocation(solutionManager, locationId, updates) {
    try {
        // Get location editor
        const locationEditor = await solutionManager.getLocation(locationId);
        
        // Apply updates
        if (updates.type) {
            locationEditor.setType(updates.type);
        }
        
        if (updates.names) {
            for (const [language, name] of Object.entries(updates.names)) {
                locationEditor.setName(language, name);
            }
        }
        
        if (updates.descriptions) {
            for (const [language, description] of Object.entries(updates.descriptions)) {
                locationEditor.setDescription(language, description);
            }
        }
        
        if (updates.position) {
            locationEditor.moveTo(updates.position);
        }
        
        if (updates.rotation !== undefined) {
            locationEditor.rotate(updates.rotation);
        }
        
        // Save changes
        await locationEditor.save();
        
        return true;
    } catch (error) {
        console.error('Error updating location:', error);
        throw error;
    }
}

// Direct integration with MapsIndoors API
class MapsIndoorsAPIClient {
    constructor(bearerToken, solutionId) {
        this.baseUrl = 'https://integration.mapsindoors.com';
        this.solutionId = solutionId;
        this.headers = {
            'Authorization': `Bearer ${bearerToken}`,
            'Content-Type': 'application/json'
        };
    }
    
    // Get geodata
    async getGeoData() {
        try {
            const response = await fetch(`${this.baseUrl}/${this.solutionId}/api/geodata`, {
                method: 'GET',
                headers: this.headers
            });
            
            if (!response.ok) {
                throw new Error(`API request failed: ${response.status} ${response.statusText}`);
            }
            
            return await response.json();
        } catch (error) {
            console.error('Error fetching geodata:', error);
            throw error;
        }
    }
    
    // Create new locations
    async createLocations(locationsData) {
        try {
            const response = await fetch(`${this.baseUrl}/${this.solutionId}/api/geodata`, {
                method: 'POST',
                headers: this.headers,
                body: JSON.stringify(locationsData)
            });
            
            if (!response.ok) {
                throw new Error(`API request failed: ${response.status} ${response.statusText}`);
            }
            
            return await response.json();
        } catch (error) {
            console.error('Error creating locations:', error);
            throw error;
        }
    }
    
    // Update existing locations
    async updateLocations(locationsData) {
        try {
            const response = await fetch(`${this.baseUrl}/${this.solutionId}/api/geodata`, {
                method: 'PUT',
                headers: this.headers,
                body: JSON.stringify(locationsData)
            });
            
            if (!response.ok) {
                throw new Error(`API request failed: ${response.status} ${response.statusText}`);
            }
            
            return await response.json();
        } catch (error) {
            console.error('Error updating locations:', error);
            throw error;
        }
    }
    
    // Delete locations
    async deleteLocations(locationIds) {
        try {
            const response = await fetch(`${this.baseUrl}/${this.solutionId}/api/geodata`, {
                method: 'DELETE',
                headers: this.headers,
                body: JSON.stringify(locationIds)
            });
            
            if (!response.ok) {
                throw new Error(`API request failed: ${response.status} ${response.statusText}`);
            }
            
            return true;
        } catch (error) {
            console.error('Error deleting locations:', error);
            throw error;
        }
    }
    
    // Get categories
    async getCategories() {
        try {
            const response = await fetch(`${this.baseUrl}/${this.solutionId}/api/categories`, {
                method: 'GET',
                headers: {
                    'accept': 'application/json'
                }
            });
            
            if (!response.ok) {
                throw new Error(`Failed to fetch categories: ${response.status}`);
            }
            
            return await response.json();
        } catch (error) {
            console.error('Error fetching categories:', error);
            throw error;
        }
    }
}
Distance Matrix and Location Services
javascript
// Use MapsIndoors Distance Matrix service
async function calculateDistanceMatrix(origins, destinations, graphId) {
    try {
        // Format origins and destinations for Distance Matrix service
        const formattedOrigins = origins.map(origin => 
            `${origin.lat},${origin.lng},${origin.floor}`
        );
        
        const formattedDestinations = destinations.map(dest => 
            `${dest.lat},${dest.lng},${dest.floor}`
        );
        
        // Calculate distance matrix
        const matrix = await mapsindoors.services.DistanceMatrixService.getDistanceMatrix({
            graphId: graphId, // Example: 'AUSTINOFFICE_Graph'
            origins: formattedOrigins,
            destinations: formattedDestinations
        });
        
        return matrix;
    } catch (error) {
        console.error('Error calculating distance matrix:', error);
        throw error;
    }
}

// Find nearest location with distance matrix
async function findNearestLocationWithMatrix(origin, locations, graphId) {
    try {
        // Format origin
        const formattedOrigin = `${origin.lat},${origin.lng},${origin.floor}`;
        
        // Format destinations from locations
        const formattedDestinations = locations.map(location => {
            const coords = location.properties.anchor.coordinates;
            return `${coords[1]},${coords[0]},${location.properties.floor}`;
        });
        
        // Get distance matrix
        const matrix = await mapsindoors.services.DistanceMatrixService.getDistanceMatrix({
            graphId: graphId,
            origins: [formattedOrigin],
            destinations: formattedDestinations
        });
        
        // Find nearest location
        let nearestIndex = 0;
        let shortestDistance = Infinity;
        
        matrix.rows[0].elements.forEach((element, index) => {
            if (element.distance.value < shortestDistance) {
                shortestDistance = element.distance.value;
                nearestIndex = index;
            }
        });
        
        return {
            location: locations[nearestIndex],
            distance: shortestDistance,
            duration: matrix.rows[0].elements[nearestIndex].duration.value
        };
    } catch (error) {
        console.error('Error finding nearest location:', error);
        throw error;
    }
}

// Use LocationsService near function to find nearby locations
async function findLocationsNear(locationId, radius, floor, types, take = 5) {
    try {
        const nearbyLocations = await mapsindoors.services.LocationsService.getLocations({
            near: `location:${locationId}`,
            radius: radius,
            floor: floor,
            types: types,
            take: take
        });
        
        return nearbyLocations;
    } catch (error) {
        console.error('Error finding nearby locations:', error);
        throw error;
    }
}
Export and Data Visualization
javascript
// Generate and export a PNG snapshot of the current map
async function exportMapAsPNG(mapboxInstance, scale = 4) {
    const mapContainer = document.getElementById('map');
    const originalStyle = {
        width: mapContainer.style.width,
        height: mapContainer.style.height
    };

    try {
        // Store original state
        const originalCenter = mapboxInstance.getCenter();
        const originalZoom = mapboxInstance.getZoom();

        // Calculate high-res dimensions
        const exportWidth = window.innerWidth * scale;
        const exportHeight = window.innerHeight * scale;
        
        // Set temporary dimensions for high-res capture
        mapContainer.style.width = `${exportWidth}px`;
        mapContainer.style.height = `${exportHeight}px`;
        
        // Update map
        mapboxInstance.resize();
        mapboxInstance.setCenter(originalCenter);
        mapboxInstance.setZoom(originalZoom);
        
        // Wait for the map to stabilize
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        // Create data URL from the canvas
        const canvas = mapboxInstance.getCanvas();
        const dataUrl = canvas.toDataURL('image/png', 1.0);
        
        // Reset map dimensions
        mapContainer.style.width = originalStyle.width;
        mapContainer.style.height = originalStyle.height;
        mapboxInstance.resize();
        mapboxInstance.setCenter(originalCenter);
        mapboxInstance.setZoom(originalZoom);
        
        // Create download link
        const a = document.createElement('a');
        a.href = dataUrl;
        a.download = `mapsindoors_export_${Date.now()}.png`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        
        return true;
    } catch (error) {
        console.error('Error exporting map as PNG:', error);
        
        // Reset map dimensions on error
        mapContainer.style.width = originalStyle.width;
        mapContainer.style.height = originalStyle.height;
        mapboxInstance.resize();
        
        throw error;
    }
}

// Export map as PDF (requires jsPDF)
async function exportMapAsPDF(mapboxInstance, scale = 4) {
    // Check if jsPDF is available
    if (typeof jsPDF !== 'function') {
        throw new Error('jsPDF is not loaded. Please include the jsPDF library.');
    }
    
    const mapContainer = document.getElementById('map');
    const originalStyle = {
        width: mapContainer.style.width,
        height: mapContainer.style.height
    };

    try {
        // Store original state
        const originalCenter = mapboxInstance.getCenter();
        const originalZoom = mapboxInstance.getZoom();
        const currentFloor = mapsIndoorsInstance.getFloor();
        const floorName = currentFloor !== null ? `Floor_${currentFloor}` : 'Ground_Floor';

        // Set larger dimensions for higher quality
        const exportWidth = window.innerWidth * scale;
        const exportHeight = window.innerHeight * scale;
        mapContainer.style.width = `${exportWidth}px`;
        mapContainer.style.height = `${exportHeight}px`;

        // Resize map and wait for it to settle
        mapboxInstance.resize();
        mapboxInstance.setCenter(originalCenter);
        mapboxInstance.setZoom(originalZoom);

        // Wait for the map to stabilize
        await new Promise(resolve => setTimeout(resolve, 2000));

        // Create a data URL from the canvas
        const canvas = mapboxInstance.getCanvas();
        const dataUrl = canvas.toDataURL('image/jpeg', 1.0);

        // Create PDF
        const pdf = new jsPDF({
            orientation: 'landscape',
            unit: 'mm',
            format: 'a4'
        });

        // Set document properties
        pdf.setProperties({
            title: `MapsIndoors Floor Plan - ${floorName}`,
            subject: 'Floor Plan',
            creator: 'MapsIndoors PDF Export Tool',
            author: 'MapsIndoors'
        });

        // Calculate dimensions to fit the page while maintaining aspect ratio
        const pdfWidth = pdf.internal.pageSize.getWidth();
        const pdfHeight = pdf.internal.pageSize.getHeight();
        const imgWidth = canvas.width;
        const imgHeight = canvas.height;
        const ratio = Math.min(pdfWidth / imgWidth, pdfHeight / imgHeight);
        
        // Center the image on the page
        const imgX = (pdfWidth - imgWidth * ratio) / 2;
        const imgY = (pdfHeight - imgHeight * ratio) / 2;

        // Add image to PDF
        pdf.addImage(dataUrl, 'JPEG', imgX, imgY, imgWidth * ratio, imgHeight * ratio);

        // Save the PDF
        pdf.save(`mapsindoors_floorplan_${floorName}_${Date.now()}.pdf`);

        // Reset map dimensions
        mapContainer.style.width = originalStyle.width;
        mapContainer.style.height = originalStyle.height;
        mapboxInstance.resize();
        mapboxInstance.setCenter(originalCenter);
        mapboxInstance.setZoom(originalZoom);
        
        return true;
    } catch (error) {
        console.error('Error exporting map as PDF:', error);
        
        // Reset map dimensions on error
        mapContainer.style.width = originalStyle.width;
        mapContainer.style.height = originalStyle.height;
        mapboxInstance.resize();
        
        throw error;
    }
}
Working with External APIs and Quickbase Integration
javascript
// Quickbase API integration for work orders
class QuickbaseAPI {
    constructor(hostname, token) {
        // Remove any protocol prefix and trailing slashes
        this.hostname = hostname.replace(/^https?:\/\//, '').replace(/\/$/, '');
        this.baseUrl = 'https://api.quickbase.com/v1';
        this.headers = {
            'QB-Realm-Hostname': this.hostname,
            'Authorization': `QB-USER-TOKEN ${token}`,
            'Content-Type': 'application/json'
        };
    }

    async getRecords(tableId, options = {}) {
        const endpoint = `${this.baseUrl}/records/query`;
        
        const body = {
            from: tableId,
            select: options.fields || [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],
            where: options.where || '',
            sortBy: options.sortBy || [],
            options: {
                skip: options.skip || 0,
                top: options.top || 100
            }
        };

        try {
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: this.headers,
                body: JSON.stringify(body)
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`API error: ${response.status} - ${errorText}`);
            }

            return await response.json();
        } catch (error) {
            console.error('Quickbase API error:', error);
            throw error;
        }
    }
    
    async createRecord(tableId, fields) {
        const endpoint = `${this.baseUrl}/records`;
        
        const body = {
            to: tableId,
            data: [{ 
                fields: fields 
            }]
        };

        try {
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: this.headers,
                body: JSON.stringify(body)
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`API error: ${response.status} - ${errorText}`);
            }

            return await response.json();
        } catch (error) {
            console.error('Quickbase API error:', error);
            throw error;
        }
    }
    
    async updateRecord(tableId, recordId, fields) {
        const endpoint = `${this.baseUrl}/records`;
        
        const body = {
            to: tableId,
            data: [{ 
                id: recordId,
                fields: fields 
            }]
        };

        try {
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: this.headers,
                body: JSON.stringify(body)
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`API error: ${response.status} - ${errorText}`);
            }

            return await response.json();
        } catch (error) {
            console.error('Quickbase API error:', error);
            throw error;
        }
    }
    
    async deleteRecord(tableId, recordId) {
        const endpoint = `${this.baseUrl}/records`;
        
        const body = {
            from: tableId,
            where: `{3.EX.'${recordId}'}`
        };

        try {
            const response = await fetch(endpoint, {
                method: 'DELETE',
                headers: this.headers,
                body: JSON.stringify(body)
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`API error: ${response.status} - ${errorText}`);
            }

            return await response.json();
        } catch (error) {
            console.error('Quickbase API error:', error);
            throw error;
        }
    }
}

// Integrate work orders with MapsIndoors
function initWorkOrderSystem(mapsIndoorsInstance, quickbaseAPI, tableId, locationIdField, statusField) {
    // Get work orders and update map
    async function updateWorkOrdersOnMap() {
        try {
            // Get work orders from Quickbase
            const result = await quickbaseAPI.getRecords(tableId);
            
            if (!result.data || result.data.length === 0) {
                console.log('No work orders found');
                return [];
            }
            
            const workOrders = result.data.map(record => {
                const fields = record.fields;
                
                // Extract location ID and status
                const locationId = fields[locationIdField];
                const status = fields[statusField];
                
                return {
                    id: record.id,
                    locationId,
                    status,
                    fields
                };
            });
            
            // Update map display rules based on work order status
            const statusColors = {
                'Open': '#f44336',
                'In Progress': '#ff9800',
                'Completed': '#4caf50',
                'Pending': '#2196f3'
            };
            
            // Group by status
            const locationsByStatus = {};
            
            workOrders.forEach(order => {
                if (!order.locationId) return;
                
                if (!locationsByStatus[order.status]) {
                    locationsByStatus[order.status] = [];
                }
                
                locationsByStatus[order.status].push(order.locationId);
            });
            
            // Apply display rules for each status group
            Object.entries(locationsByStatus).forEach(([status, locationIds]) => {
                const color = statusColors[status] || '#9e9e9e';
                
                mapsIndoorsInstance.setDisplayRule(locationIds, {
                    polygonVisible: true,
                    polygonFillColor: color,
                    polygonFillOpacity: 0.5,
                    polygonStrokeColor: color,
                    polygonStrokeOpacity: 0.8,
                    polygonStrokeWidth: 1,
                    zoomFrom: 16
                });
            });
            
            return workOrders;
        } catch (error) {
            console.error('Error updating work orders:', error);
            return [];
        }
    }
    
    // Create a new work order
    async function createWorkOrder(locationId, fields) {
        try {
            // Add location ID to fields
            fields[locationIdField] = locationId;
            
            // Create record
            const result = await quickbaseAPI.createRecord(tableId, fields);
            
            // Update map
            await updateWorkOrdersOnMap();
            
            return result;
        } catch (error) {
            console.error('Error creating work order:', error);
            throw error;
        }
    }
    
    // Update work order status
    async function updateWorkOrderStatus(recordId, status) {
        try {
            // Update record
            const result = await quickbaseAPI.updateRecord(tableId, recordId, {
                [statusField]: status
            });
            
            // Update map
            await updateWorkOrdersOnMap();
            
            return result;
        } catch (error) {
            console.error('Error updating work order status:', error);
            throw error;
        }
    }
    
    // Return public methods
    return {
        updateWorkOrdersOnMap,
        createWorkOrder,
        updateWorkOrderStatus
    };
}
Complete Example: Room Booking Application
Here's a complete example that brings together many of the concepts we've covered to create a room booking application:

javascript
// Room Booking Application
document.addEventListener('DOMContentLoaded', function() {
    // Initialize MapsIndoors
    const mapViewOptions = {
        accessToken: 'YOUR_MAPBOX_TOKEN',
        element: document.getElementById('map'),
        center: { lat: 30.3603212, lng: -97.7422623 },
        zoom: 20,
        maxZoom: 22,
    };

    const mapViewInstance = new mapsindoors.mapView.MapboxV3View(mapViewOptions);
    const mapsIndoorsInstance = new mapsindoors.MapsIndoors({
        mapView: mapViewInstance,
    });
    const mapboxInstance = mapViewInstance.getMap();

    // Add floor selector
    const floorSelectorElement = document.createElement('div');
    new mapsindoors.FloorSelector(floorSelectorElement, mapsIndoorsInstance);
    mapboxInstance.addControl({ 
        onAdd: function () { return floorSelectorElement },
        onRemove: function () { }
    });

    // Global variables
    let roomsData = [];
    let selectedRoomId = null;
    let currentFilter = 'all';
    let searchTerm = '';

    // Add UI elements
    const searchContainer = createSearchUI(
        (term) => {
            searchTerm = term;
            renderRoomList();
        },
        (filter) => {
            currentFilter = filter;
            renderRoomList();
        }
    );
    document.body.appendChild(searchContainer);

    const detailPanel = createLocationDetailPanel();
    document.body.appendChild(detailPanel.element);

    // Map control buttons
    const mapControls = document.createElement('div');
    mapControls.style.cssText = `
        position: absolute;
        top: 20px;
        right: 20px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        z-index: 10;
    `;

    mapControls.innerHTML = `
        <button class="map-control-btn" id="zoom-in" style="width: 40px; height: 40px; background: white; border: none; border-radius: 4px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); cursor: pointer;">
            <i class="fas fa-plus"></i>
        </button>
        <button class="map-control-btn" id="zoom-out" style="width: 40px; height: 40px; background: white; border: none; border-radius: 4px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); cursor: pointer;">
            <i class="fas fa-minus"></i>
        </button>
        <button class="map-control-btn" id="recenter" style="width: 40px; height: 40px; background: white; border: none; border-radius: 4px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); cursor: pointer;">
            <i class="fas fa-crosshairs"></i>
        </button>
    `;
    document.body.appendChild(mapControls);

    document.getElementById('zoom-in').addEventListener('click', () => mapboxInstance.zoomIn());
    document.getElementById('zoom-out').addEventListener('click', () => mapboxInstance.zoomOut());
    document.getElementById('recenter').addEventListener('click', recenterMap);

    // Initialize room booking system
    let bookingSystem = null;

    // MapsIndoors ready event
    mapsIndoorsInstance.addListener('ready', async function() {
        console.log('MapsIndoors is ready');
        
        // Get meeting rooms
        const locations = await mapsindoors.services.LocationsService.getLocations({
            types: ['MeetingRoom', 'MeetingRoom Small', 'MeetingRoom Extra Small', 'MeetingRoom Medium', 'MeetingRoom Large'],
            venue: 'AUSTINOFFICE',
            take: 100
        });
        
        console.log(`Found ${locations.length} meeting rooms`);
        
        // If not enough rooms, get other locations with polygons
        let meetingRooms = [...locations];
        if (meetingRooms.length < 5) {
            const additionalLocations = await mapsindoors.services.LocationsService.getLocations({
                venue: 'AUSTINOFFICE',
                take: 100
            });
            
            const roomCandidates = additionalLocations.filter(location => {
                return location.geometry && 
                      (location.geometry.type === "Polygon" || 
                       location.geometry.type === "MultiPolygon") &&
                      !meetingRooms.some(room => room.id === location.id);
            });
            
            meetingRooms = [...meetingRooms, ...roomCandidates.slice(0, 10)];
        }
        
        // Process room data
        roomsData = meetingRooms.map(location => {
            return {
                id: location.id,
                name: location.properties.name || 'Unnamed Room',
                floor: location.properties.floor,
                building: location.properties.building,
                type: location.properties.type || 'Meeting Room',
                capacity: Math.floor(Math.random() * 15) + 2, // Random capacity for demo
                location: {
                    lat: location.properties.anchor.coordinates[1],
                    lng: location.properties.anchor.coordinates[0]
                },
                geometry: location.geometry,
                status: Math.random() > 0.5 ? 'available' : 'occupied', // Random initial status
                bookings: [],
                features: [
                    'Wi-Fi',
                    Math.random() > 0.3 ? 'Display Screen' : null,
                    Math.random() > 0.5 ? 'Video Conferencing' : null,
                    Math.random() > 0.7 ? 'Whiteboard' : null
                ].filter(Boolean)
            };
        });
        
        // Initialize booking system
        bookingSystem = initializeRoomStatusSystem(mapsIndoorsInstance, roomsData);
        
        // Update display rules based on availability
        updateRoomDisplayRules();
        
        // Render room list
        renderRoomList();
        
        // Setup event listeners
        setupEventListeners();
        
        // Set initial floor to most populated one
        const floorCounts = {};
        roomsData.forEach(room => {
            floorCounts[room.floor] = (floorCounts[room.floor] || 0) + 1;
        });
        
        const mostPopulatedFloor = Object.entries(floorCounts)
            .sort((a, b) => b[1] - a[1])[0][0];
        
        mapsIndoorsInstance.setFloor(parseInt(mostPopulatedFloor));
        
        // Center map on rooms
        recenterMap();
    });

    // Setup event listeners
    function setupEventListeners() {
        // MapsIndoors click event
        mapsIndoorsInstance.addListener('click', (event) => {
            if (event && event.id) {
                const room = roomsData.find(r => r.id === event.id);
                if (room) {
                    selectRoom(room.id);
                }
            }
        });
    }

    // Update room display rules based on status
    function updateRoomDisplayRules() {
        // Group rooms by status
        const availableRooms = roomsData.filter(room => room.status === 'available').map(room => room.id);
        const occupiedRooms = roomsData.filter(room => room.status === 'occupied').map(room => room.id);
        
        // Apply display rules based on status
        mapsIndoorsInstance.setDisplayRule(availableRooms, {
            polygonVisible: true,
            polygonFillColor: '#4CAF50', // Green for available
            polygonFillOpacity: 0.5,
            polygonStrokeColor: '#4CAF50',
            polygonStrokeOpacity: 0.8,
            polygonStrokeWidth: 1,
            zoomFrom: 16
        });
        
        mapsIndoorsInstance.setDisplayRule(occupiedRooms, {
            polygonVisible: true,
            polygonFillColor: '#F44336', // Red for occupied
            polygonFillOpacity: 0.5,
            polygonStrokeColor: '#F44336',
            polygonStrokeOpacity: 0.8,
            polygonStrokeWidth: 1,
            zoomFrom: 16
        });
        
        // Highlight selected room if any
        if (selectedRoomId) {
            const room = roomsData.find(r => r.id === selectedRoomId);
            if (room) {
                const color = room.status === 'available' ? '#4CAF50' : '#F44336';
                
                mapsIndoorsInstance.setDisplayRule(selectedRoomId, {
                    polygonVisible: true,
                    polygonFillOpacity: 0.8,
                    polygonStrokeOpacity: 1,
                    polygonStrokeWidth: 3,
                    zoomFrom: 16
                });
            }
        }
    }

    // Select a room
    function selectRoom(roomId) {
        selectedRoomId = roomId;
        const room = roomsData.find(r => r.id === roomId);
        if (!room) return;
        
        // Center map on room
        mapboxInstance.flyTo({
            center: [room.location.lng, room.location.lat],
            zoom: 21,
            duration: 1000
        });
        
        // Set floor to match room
        mapsIndoorsInstance.setFloor(room.floor);
        
        // Update room highlights
        updateRoomDisplayRules();
        
        // Update detail panel
        updateRoomDetailPanel(room);
    }

    // Update room detail panel
    function updateRoomDetailPanel(room) {
        // Define actions based on room status
        const actions = [];
        
        if (room.status === 'available') {
            actions.push({
                text: 'Book Now',
                icon: 'fas fa-calendar-plus',
                type: 'primary',
                onClick: (location) => bookRoom(location.id)
            });
        } else {
            actions.push({
                text: 'Join Waiting List',
                icon: 'fas fa




Continue

Edit
I'll continue with the Room Booking Application example:

javascript
                text: 'Join Waiting List',
                icon: 'fas fa-clock',
                type: 'primary',
                onClick: (location) => joinWaitlist(location.id)
            });
            
            actions.push({
                text: 'View Schedule',
                icon: 'fas fa-calendar-alt',
                type: 'secondary',
                onClick: (location) => viewRoomSchedule(location.id)
            });
        }
        
        // Create a list of room features
        const roomFeatures = room.features.map(feature => {
            let icon = 'fas fa-check';
            
            if (feature.includes('Display')) icon = 'fas fa-tv';
            if (feature.includes('Video')) icon = 'fas fa-video';
            if (feature.includes('Wi-Fi')) icon = 'fas fa-wifi';
            if (feature.includes('Whiteboard')) icon = 'fas fa-chalkboard';
            
            return { name: feature, icon };
        });
        
        // Add standard details
        roomFeatures.unshift({
            name: `Capacity: ${room.capacity} people`,
            icon: 'fas fa-users'
        });
        
        // Update the detail panel
        detailPanel.update({
            properties: {
                name: room.name,
                floor: room.floor,
                type: room.type,
                status: room.status
            }
        }, actions);
    }

    // Render room list
    function renderRoomList() {
        const container = document.querySelector('.room-list') || document.createElement('div');
        container.className = 'room-list';
        container.style.cssText = `
            position: absolute;
            left: 20px;
            top: 150px;
            max-height: calc(100vh - 200px);
            width: 300px;
            overflow-y: auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 15px;
            z-index: 10;
        `;
        
        // Filter rooms
        let filteredRooms = roomsData.filter(room => {
            // Filter by search term
            if (searchTerm && !room.name.toLowerCase().includes(searchTerm.toLowerCase())) {
                return false;
            }
            
            // Filter by status
            if (currentFilter !== 'all' && currentFilter !== room.type) {
                return false;
            }
            
            return true;
        });
        
        // Sort rooms: available first, then by name
        filteredRooms.sort((a, b) => {
            if (a.status !== b.status) {
                return a.status === 'available' ? -1 : 1;
            }
            return a.name.localeCompare(b.name);
        });
        
        // Create room list
        let html = `<h3 style="margin-top: 0; margin-bottom: 15px;">Available Rooms (${filteredRooms.length})</h3>`;
        
        if (filteredRooms.length === 0) {
            html += `
                <div style="text-align: center; padding: 20px; color: #666;">
                    <i class="fas fa-search" style="font-size: 24px; margin-bottom: 10px;"></i>
                    <p>No rooms match your criteria.</p>
                </div>
            `;
        } else {
            filteredRooms.forEach(room => {
                const isSelected = selectedRoomId === room.id;
                const statusColor = room.status === 'available' ? '#4CAF50' : '#F44336';
                const statusText = room.status === 'available' ? 'Available' : 'Occupied';
                const statusIcon = room.status === 'available' ? 'fas fa-check-circle' : 'fas fa-times-circle';
                
                html += `
                    <div class="room-card ${isSelected ? 'selected' : ''}" 
                         data-id="${room.id}" 
                         style="
                            background: white;
                            border-radius: 8px;
                            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
                            padding: 15px;
                            margin-bottom: 15px;
                            border-left: 4px solid ${statusColor};
                            cursor: pointer;
                            ${isSelected ? 'box-shadow: 0 0 0 2px #FF9800;' : ''}
                         ">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                            <div style="font-weight: 600;">${room.name}</div>
                            <div style="
                                color: ${statusColor};
                                font-size: 0.8rem;
                                display: flex;
                                align-items: center;
                                gap: 5px;
                            ">
                                <i class="${statusIcon}"></i>
                                <span>${statusText}</span>
                            </div>
                        </div>
                        <div style="font-size: 0.85rem; color: #666;">
                            <div>Floor ${room.floor}</div>
                            <div>Capacity: ${room.capacity} people</div>
                        </div>
                    </div>
                `;
            });
        }
        
        container.innerHTML = html;
        
        // Add click handlers
        container.querySelectorAll('.room-card').forEach(card => {
            card.addEventListener('click', () => {
                selectRoom(card.dataset.id);
            });
        });
        
        // Add to document if not already there
        if (!document.body.contains(container)) {
            document.body.appendChild(container);
        }
    }

    // Book a room
    function bookRoom(roomId) {
        const room = roomsData.find(r => r.id === roomId);
        if (!room || room.status !== 'available') {
            createToast('This room is not available for booking', 'error');
            return;
        }
        
        // Show booking modal
        const modal = document.createElement('div');
        modal.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        `;
        
        modal.innerHTML = `
            <div style="
                background: white;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
                width: 400px;
                max-width: 90%;
                padding: 20px;
            ">
                <h2 style="margin-top: 0;">Book ${room.name}</h2>
                <form id="booking-form">
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 500;">Date</label>
                        <input type="date" id="booking-date" required style="
                            width: 100%;
                            padding: 8px;
                            border: 1px solid #ddd;
                            border-radius: 4px;
                        ">
                    </div>
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 500;">Time</label>
                        <div style="display: flex; gap: 10px;">
                            <select id="booking-start-time" required style="
                                flex: 1;
                                padding: 8px;
                                border: 1px solid #ddd;
                                border-radius: 4px;
                            ">
                                ${generateTimeOptions(8, 17)}
                            </select>
                            <span style="align-self: center;">to</span>
                            <select id="booking-end-time" required style="
                                flex: 1;
                                padding: 8px;
                                border: 1px solid #ddd;
                                border-radius: 4px;
                            ">
                                ${generateTimeOptions(9, 18)}
                            </select>
                        </div>
                    </div>
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 500;">Purpose</label>
                        <input type="text" id="booking-purpose" placeholder="Meeting purpose" required style="
                            width: 100%;
                            padding: 8px;
                            border: 1px solid #ddd;
                            border-radius: 4px;
                        ">
                    </div>
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 500;">Attendees</label>
                        <input type="number" id="booking-attendees" min="1" max="${room.capacity}" value="2" required style="
                            width: 100%;
                            padding: 8px;
                            border: 1px solid #ddd;
                            border-radius: 4px;
                        ">
                        <small style="color: #666;">Maximum capacity: ${room.capacity}</small>
                    </div>
                    <div style="display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px;">
                        <button type="button" id="cancel-booking" style="
                            padding: 8px 16px;
                            border: none;
                            border-radius: 4px;
                            background: #e0e0e0;
                            cursor: pointer;
                        ">Cancel</button>
                        <button type="submit" style="
                            padding: 8px 16px;
                            border: none;
                            border-radius: 4px;
                            background: #4CAF50;
                            color: white;
                            cursor: pointer;
                        ">Book Now</button>
                    </div>
                </form>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        // Set default date to today
        const today = new Date();
        const dateStr = today.toISOString().split('T')[0];
        document.getElementById('booking-date').value = dateStr;
        
        // Cancel button handler
        document.getElementById('cancel-booking').addEventListener('click', () => {
            document.body.removeChild(modal);
        });
        
        // Form submit handler
        document.getElementById('booking-form').addEventListener('submit', (e) => {
            e.preventDefault();
            
            const date = document.getElementById('booking-date').value;
            const startTime = document.getElementById('booking-start-time').value;
            const endTime = document.getElementById('booking-end-time').value;
            const purpose = document.getElementById('booking-purpose').value;
            const attendees = document.getElementById('booking-attendees').value;
            
            // Validate times
            if (startTime >= endTime) {
                alert('End time must be after start time');
                return;
            }
            
            // Create booking
            const startDateTime = new Date(`${date}T${startTime}`);
            const endDateTime = new Date(`${date}T${endTime}`);
            
            const bookingResult = bookingSystem.bookRoom(
                roomId,
                startDateTime,
                endDateTime,
                'current-user',
                purpose
            );
            
            if (bookingResult.success) {
                // Update room status
                room.status = 'occupied';
                updateRoomDisplayRules();
                updateRoomDetailPanel(room);
                renderRoomList();
                
                // Show success message
                createToast(`Successfully booked ${room.name}`, 'success');
            } else {
                // Show error message
                createToast(bookingResult.message, 'error');
            }
            
            // Close modal
            document.body.removeChild(modal);
        });
    }

    // Join room waitlist
    function joinWaitlist(roomId) {
        const room = roomsData.find(r => r.id === roomId);
        if (!room) return;
        
        // Show waitlist modal
        const modal = document.createElement('div');
        modal.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        `;
        
        modal.innerHTML = `
            <div style="
                background: white;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
                width: 400px;
                max-width: 90%;
                padding: 20px;
            ">
                <h2 style="margin-top: 0;">Join Waitlist for ${room.name}</h2>
                <form id="waitlist-form">
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 500;">Date</label>
                        <input type="date" id="waitlist-date" required style="
                            width: 100%;
                            padding: 8px;
                            border: 1px solid #ddd;
                            border-radius: 4px;
                        ">
                    </div>
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 500;">Preferred Time</label>
                        <div style="display: flex; gap: 10px;">
                            <select id="waitlist-start-time" required style="
                                flex: 1;
                                padding: 8px;
                                border: 1px solid #ddd;
                                border-radius: 4px;
                            ">
                                ${generateTimeOptions(8, 17)}
                            </select>
                            <span style="align-self: center;">to</span>
                            <select id="waitlist-end-time" required style="
                                flex: 1;
                                padding: 8px;
                                border: 1px solid #ddd;
                                border-radius: 4px;
                            ">
                                ${generateTimeOptions(9, 18)}
                            </select>
                        </div>
                    </div>
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 500;">Purpose</label>
                        <input type="text" id="waitlist-purpose" placeholder="Meeting purpose" required style="
                            width: 100%;
                            padding: 8px;
                            border: 1px solid #ddd;
                            border-radius: 4px;
                        ">
                    </div>
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 500;">Attendees</label>
                        <input type="number" id="waitlist-attendees" min="1" max="${room.capacity}" value="2" required style="
                            width: 100%;
                            padding: 8px;
                            border: 1px solid #ddd;
                            border-radius: 4px;
                        ">
                        <small style="color: #666;">Maximum capacity: ${room.capacity}</small>
                    </div>
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 500;">Your Name</label>
                        <input type="text" id="waitlist-name" required style="
                            width: 100%;
                            padding: 8px;
                            border: 1px solid #ddd;
                            border-radius: 4px;
                        ">
                    </div>
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 500;">Your Email</label>
                        <input type="email" id="waitlist-email" required style="
                            width: 100%;
                            padding: 8px;
                            border: 1px solid #ddd;
                            border-radius: 4px;
                        ">
                    </div>
                    <div style="display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px;">
                        <button type="button" id="cancel-waitlist" style="
                            padding: 8px 16px;
                            border: none;
                            border-radius: 4px;
                            background: #e0e0e0;
                            cursor: pointer;
                        ">Cancel</button>
                        <button type="submit" style="
                            padding: 8px 16px;
                            border: none;
                            border-radius: 4px;
                            background: #2196F3;
                            color: white;
                            cursor: pointer;
                        ">Join Waitlist</button>
                    </div>
                </form>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        // Set default date to today
        const today = new Date();
        const dateStr = today.toISOString().split('T')[0];
        document.getElementById('waitlist-date').value = dateStr;
        
        // Cancel button handler
        document.getElementById('cancel-waitlist').addEventListener('click', () => {
            document.body.removeChild(modal);
        });
        
        // Form submit handler
        document.getElementById('waitlist-form').addEventListener('submit', (e) => {
            e.preventDefault();
            
            // In a real app, this would submit to a server
            createToast(`You've been added to the waitlist for ${room.name}`, 'success');
            
            // Close modal
            document.body.removeChild(modal);
        });
    }

    // View room schedule
    function viewRoomSchedule(roomId) {
        const room = roomsData.find(r => r.id === roomId);
        if (!room) return;
        
        // Generate sample bookings if none exist
        if (!room.bookings || room.bookings.length === 0) {
            generateSampleBookings(room);
        }
        
        // Show schedule modal
        const modal = document.createElement('div');
        modal.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        `;
        
        // Generate HTML for today's schedule
        const today = new Date();
        const dateStr = today.toISOString().split('T')[0];
        
        const schedule = generateScheduleHTML(room, today);
        
        modal.innerHTML = `
            <div style="
                background: white;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
                width: 500px;
                max-width: 90%;
                max-height: 90vh;
                overflow-y: auto;
                padding: 20px;
            ">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2 style="margin: 0;">${room.name} Schedule</h2>
                    <button id="close-schedule" style="
                        background: none;
                        border: none;
                        font-size: 1.5rem;
                        cursor: pointer;
                        padding: 0;
                    ">×</button>
                </div>
                
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <button id="prev-day" style="
                        background: none;
                        border: none;
                        font-size: 1.5rem;
                        cursor: pointer;
                    ">‹</button>
                    <h3 id="schedule-date" style="margin: 0;">${formatDate(today)}</h3>
                    <button id="next-day" style="
                        background: none;
                        border: none;
                        font-size: 1.5rem;
                        cursor: pointer;
                    ">›</button>
                </div>
                
                <div id="schedule-container">
                    ${schedule}
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        // Close button handler
        document.getElementById('close-schedule').addEventListener('click', () => {
            document.body.removeChild(modal);
        });
        
        // Initialize date navigation
        let currentDate = new Date(today);
        
        // Previous day handler
        document.getElementById('prev-day').addEventListener('click', () => {
            currentDate.setDate(currentDate.getDate() - 1);
            updateSchedule();
        });
        
        // Next day handler
        document.getElementById('next-day').addEventListener('click', () => {
            currentDate.setDate(currentDate.getDate() + 1);
            updateSchedule();
        });
        
        // Update schedule when date changes
        function updateSchedule() {
            document.getElementById('schedule-date').textContent = formatDate(currentDate);
            document.getElementById('schedule-container').innerHTML = generateScheduleHTML(room, currentDate);
        }
    }

    // Generate time options for dropdowns
    function generateTimeOptions(startHour, endHour) {
        let options = '';
        for (let hour = startHour; hour <= endHour; hour++) {
            const hourStr = hour.toString().padStart(2, '0');
            options += `<option value="${hourStr}:00">${hourStr}:00</option>`;
            if (hour < endHour) {
                options += `<option value="${hourStr}:30">${hourStr}:30</option>`;
            }
        }
        return options;
    }

    // Generate sample bookings for a room
    function generateSampleBookings(room) {
        const today = new Date();
        room.bookings = [];
        
        // Generate 1-3 random bookings for today
        const numBookings = Math.floor(Math.random() * 3) + 1;
        const hours = [9, 10, 11, 13, 14, 15, 16];
        
        for (let i = 0; i < numBookings; i++) {
            const startHour = hours[Math.floor(Math.random() * hours.length)];
            const duration = Math.random() > 0.7 ? 2 : 1; // 30% chance of 2-hour meeting
            
            const startTime = new Date(today);
            startTime.setHours(startHour, 0, 0, 0);
            
            const endTime = new Date(startTime);
            endTime.setHours(startTime.getHours() + duration);
            
            room.bookings.push({
                id: `booking-${Date.now()}-${i}`,
                startTime,
                endTime,
                userId: 'sample-user',
                purpose: ['Team Meeting', 'Client Call', 'Project Review', 'Workshop', 'Interview'][Math.floor(Math.random() * 5)],
                attendees: Math.floor(Math.random() * room.capacity) + 1
            });
            
            // Remove this hour from available hours
            const index = hours.indexOf(startHour);
            if (index > -1) {
                hours.splice(index, 1);
                if (duration > 1 && hours.includes(startHour + 1)) {
                    const nextIndex = hours.indexOf(startHour + 1);
                    hours.splice(nextIndex, 1);
                }
            }
        }
    }

    // Generate HTML for a room's schedule
    function generateScheduleHTML(room, date) {
        // Get bookings for this date
        const dayStart = new Date(date);
        dayStart.setHours(0, 0, 0, 0);
        
        const dayEnd = new Date(date);
        dayEnd.setHours(23, 59, 59, 999);
        
        const bookings = room.bookings.filter(booking => 
            booking.startTime >= dayStart && booking.startTime < dayEnd
        );
        
        // Sort bookings by start time
        bookings.sort((a, b) => a.startTime - b.startTime);
        
        // Generate time slots
        let html = '';
        const workHours = [8, 9, 10, 11, 12, 13, 14, 15, 16, 17];
        
        for (const hour of workHours) {
            const startTime = new Date(date);
            startTime.setHours(hour, 0, 0, 0);
            
            const endTime = new Date(date);
            endTime.setHours(hour + 1, 0, 0, 0);
            
            // Check if there's a booking for this slot
            const booking = bookings.find(b => 
                (b.startTime < endTime && b.endTime > startTime)
            );
            
            const isBooked = !!booking;
            const bgColor = isBooked ? '#ffebee' : '#e8f5e9';
            const textColor = isBooked ? '#d32f2f' : '#2e7d32';
            const status = isBooked ? 'Booked' : 'Available';
            const icon = isBooked ? 'fas fa-calendar-check' : 'fas fa-check-circle';
            
            html += `
                <div style="
                    background-color: ${bgColor};
                    color: ${textColor};
                    padding: 12px;
                    border-radius: 4px;
                    margin-bottom: 8px;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                ">
                    <div>
                        <div style="font-weight: 500;">${formatTimeHour(hour)}</div>
                        <div style="display: flex; align-items: center; gap: 5px; margin-top: 5px;">
                            <i class="${icon}"></i>
                            <span>${status}</span>
                        </div>
                    </div>
                    ${isBooked ? `
                        <div style="text-align: right;">
                            <div style="font-weight: 500;">${booking.purpose}</div>
                            <div style="font-size: 0.8rem; margin-top: 3px;">
                                ${formatTimeRange(booking.startTime, booking.endTime)}
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
        }
        
        return html;
    }

    // Format a date for display
    function formatDate(date) {
        return date.toLocaleDateString('en-US', { 
            weekday: 'long',
            month: 'long', 
            day: 'numeric' 
        });
    }

    // Format time with AM/PM
    function formatTimeHour(hour) {
        return `${hour % 12 || 12} ${hour < 12 ? 'AM' : 'PM'}`;
    }

    // Format time range
    function formatTimeRange(start, end) {
        const startStr = start.toLocaleTimeString('en-US', { 
            hour: 'numeric', 
            minute: '2-digit',
            hour12: true 
        });
        const endStr = end.toLocaleTimeString('en-US', { 
            hour: 'numeric',
            minute: '2-digit', 
            hour12: true 
        });
        return `${startStr} - ${endStr}`;
    }

    // Recenter map on all rooms
    function recenterMap() {
        if (roomsData.length === 0) return;
        
        // Create bounds object
        const bounds = new mapboxgl.LngLatBounds();
        
        // Add all room locations to bounds
        roomsData.forEach(room => {
            bounds.extend([room.location.lng, room.location.lat]);
        });
        
        // Fit map to bounds
        mapboxInstance.fitBounds(bounds, {
            padding: 50,
            duration: 1000
        });
    }

    // Error handling
    mapsIndoorsInstance.addListener('error', function(error) {
        console.error('MapsIndoors error:', error);
        createToast('Error loading map data', 'error');
    });
});
Best Practices and Common Pitfalls
Here are some important best practices and common issues to be aware of when working with MapsIndoors:

Always Use MapboxV3View: For all new projects, use MapboxV3View instead of MapboxView as it provides better performance and compatibility.
Event Listeners: Be sure to add event listeners after MapsIndoors is ready:
javascript
mapsIndoorsInstance.addListener('ready', function() {
    // Add your event listeners here
});
Floor Navigation: Always set the floor when navigating to a location to ensure the right content is displayed:
javascript
function goToLocation(location) {
    mapboxInstance.flyTo({
        center: [location.lng, location.lat],
        zoom: 20
    });
    mapsIndoorsInstance.setFloor(location.floor);
}
Handling API Tokens: Never hardcode your API tokens in client-side code. Use environment variables or server-side authentication:
javascript
// Bad - hardcoded token
const token = 'my-secret-token';

// Better - from environment variable
const token = process.env.MAPBOX_TOKEN;

// For frontend, load from your backend
async function getToken() {
    const response = await fetch('/api/get-mapbox-token');
    return response.text();
}
Error Handling: Always include error handling for API calls and initialization:
javascript
try {
    // API call or initialization
} catch (error) {
    console.error('Error:', error);
    // Show user-friendly error message
}
Memory Management: Clean up resources when they're no longer needed:
javascript
// Remove event listeners when component unmounts
function cleanup() {
    mapsIndoorsInstance.removeListener('click', handleClick);
    markers.forEach(marker => marker.remove());
}
Performance Optimization: Be mindful of performance, especially when dealing with large datasets:
Use pagination when fetching large numbers of locations
Only show what's needed at the current zoom level
Batch updates to display rules
Common Issues:
Incorrect initialization order (Mapbox must be initialized before MapsIndoors)
Missing error handling for asynchronous operations
Not waiting for the 'ready' event before interacting with MapsIndoors
Forgetting to update display rules after changing location properties
Conclusion
This guide covers the fundamental aspects of implementing MapsIndoors in a web application. By following





Continue

Edit
I'll continue with the conclusion and add a few more important sections to complete this comprehensive MapsIndoors implementation guide:

Conclusion (continued)
This guide covers the fundamental aspects of implementing MapsIndoors in a web application. By following these patterns and best practices, you can build powerful indoor mapping solutions that provide real value to users. Remember that MapsIndoors is a flexible platform that can be customized to fit many different use cases beyond what's covered here.

Advanced Configuration Options
Here are some additional configuration options that can enhance your MapsIndoors implementation:

javascript
// Configure MapsIndoors solution settings
function configureSolutionSettings(mapsIndoorsInstance) {
    // Get the current solution configuration
    const solutionConfig = mapsIndoorsInstance.getSolutionConfig();
    
    // Adjust collision handling (0: default, 1: show all pois, 2: priority based)
    solutionConfig.collisionHandling = 0;
    
    // Set automated zoom limit - controls at what zoom levels MapsIndoors will
    // automatically adjust what POIs are shown based on importance
    solutionConfig.automatedZoomLimit = 10;
    
    // Customize selection state appearance
    solutionConfig.stateDisplayRules.selection.icon = "https://path-to-your-custom-selection-icon.svg";
    
    // Update the configuration
    mapsIndoorsInstance.setSolutionConfig(solutionConfig);
}

// Configure custom map appearance with Mapbox
function customizeMapAppearance(mapboxInstance) {
    // Add custom layer
    mapboxInstance.addLayer({
        'id': 'custom-overlay',
        'type': 'fill',
        'source': {
            'type': 'geojson',
            'data': {
                'type': 'Feature',
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': [
                        // Define your polygon coordinates here
                    ]
                },
                'properties': {
                    'name': 'Custom Area'
                }
            }
        },
        'layout': {},
        'paint': {
            'fill-color': '#0088cc',
            'fill-opacity': 0.2,
            'fill-outline-color': '#0088cc'
        }
    });
    
    // Set up 3D building extrusion (for outdoor context)
    mapboxInstance.addLayer({
        'id': '3d-buildings',
        'source': 'composite',
        'source-layer': 'building',
        'filter': ['==', 'extrude', 'true'],
        'type': 'fill-extrusion',
        'minzoom': 15,
        'paint': {
            'fill-extrusion-color': '#aaa',
            'fill-extrusion-height': [
                'interpolate', ['linear'], ['zoom'],
                15, 0,
                15.05, ['get', 'height']
            ],
            'fill-extrusion-base': [
                'interpolate', ['linear'], ['zoom'],
                15, 0,
                15.05, ['get', 'min_height']
            ],
            'fill-extrusion-opacity': 0.6
        }
    });
}

// Setup offline mode capabilities
function setupOfflineSupport(mapsIndoorsInstance) {
    // Check if offline data is available
    mapsIndoorsInstance.isOfflineDataAvailable()
        .then(isAvailable => {
            console.log('Offline data available:', isAvailable);
            
            if (!isAvailable) {
                // Start downloading data for offline use
                return mapsIndoorsInstance.downloadOfflineData();
            }
        })
        .then(() => {
            console.log('Offline data downloaded successfully');
            
            // Enable offline mode
            return mapsIndoorsInstance.enableOfflineMode(true);
        })
        .catch(error => {
            console.error('Error setting up offline mode:', error);
        });
}
Performance Optimization
To ensure your MapsIndoors implementation runs smoothly, consider these performance optimization techniques:

javascript
// Optimize performance for large venues
function optimizeForLargeVenues(mapsIndoorsInstance) {
    // Limit the number of POIs shown at once
    const displayRules = {};
    
    // Only show important POIs at lower zoom levels
    displayRules.zoomFrom = 18;
    
    // Apply display rules to all POIs
    mapsIndoorsInstance.setDisplayRule('*', displayRules);
    
    // Only load data for the current floor plus one above and below
    const floorSelectionOptions = {
        enableNearbyFloors: true,
        nearbyFloorCount: 1
    };
    
    mapsIndoorsInstance.setFloorSelector(floorSelectionOptions);
}

// Optimize rendering performance
function optimizeRendering(mapsIndoorsInstance, mapboxInstance) {
    // Reduce frame rate when not interacting with the map
    let frameThrottle;
    
    mapboxInstance.on('movestart', () => {
        mapboxInstance.setRenderFrameRate(60); // Full frame rate during movement
        clearTimeout(frameThrottle);
    });
    
    mapboxInstance.on('moveend', () => {
        frameThrottle = setTimeout(() => {
            mapboxInstance.setRenderFrameRate(30); // Reduced when idle
        }, 2000);
    });
    
    // Disable animations during route rendering to improve performance
    const directionsRendererOptions = {
        animationDuration: 0
    };
    
    const directionsRenderer = new mapsindoors.directions.DirectionsRenderer({
        mapsIndoors: mapsIndoorsInstance,
        ...directionsRendererOptions
    });
}

// Batch update display rules for better performance
function batchUpdateDisplayRules(mapsIndoorsInstance, locations, statusProperty) {
    // Group locations by status in one pass
    const locationsByStatus = {};
    
    locations.forEach(location => {
        const status = location[statusProperty] || 'default';
        
        if (!locationsByStatus[status]) {
            locationsByStatus[status] = [];
        }
        
        locationsByStatus[status].push(location.id);
    });
    
    // Apply display rules in batches
    Object.entries(locationsByStatus).forEach(([status, locationIds]) => {
        // Define display rule based on status
        const displayRule = getDisplayRuleForStatus(status);
        
        // Apply to all locations with this status at once
        mapsIndoorsInstance.setDisplayRule(locationIds, displayRule);
    });
}
Integration with Building Management Systems
MapsIndoors can integrate with building management systems (BMS) and IoT sensors to provide real-time information:

javascript
// Connect to an IoT platform or building management system
class BMSConnector {
    constructor(apiKey, endpoint) {
        this.apiKey = apiKey;
        this.endpoint = endpoint;
        this.ws = null;
    }
    
    connect() {
        // Connect to BMS websocket
        this.ws = new WebSocket(`${this.endpoint}?apiKey=${this.apiKey}`);
        
        this.ws.onopen = () => {
            console.log('Connected to building management system');
            this.subscribe(['temperature', 'occupancy', 'energy']);
        };
        
        this.ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            this.handleUpdate(data);
        };
        
        this.ws.onerror = (error) => {
            console.error('BMS connection error:', error);
        };
        
        this.ws.onclose = () => {
            console.log('BMS connection closed');
            // Attempt to reconnect after delay
            setTimeout(() => this.connect(), 5000);
        };
    }
    
    subscribe(topics) {
        if (this.ws.readyState === WebSocket.OPEN) {
            this.ws.send(JSON.stringify({
                action: 'subscribe',
                topics: topics
            }));
        }
    }
    
    handleUpdate(data) {
        // Process incoming data
        switch (data.type) {
            case 'temperature':
                updateTemperatureData(data);
                break;
                
            case 'occupancy':
                updateOccupancyData(data);
                break;
                
            case 'energy':
                updateEnergyData(data);
                break;
                
            default:
                console.log('Unknown data type:', data.type);
        }
    }
}

// Update room temperature visualization
function updateTemperatureData(data) {
    if (!data.locations || !Array.isArray(data.locations)) return;
    
    // Temperature color scale
    const getTemperatureColor = (temp) => {
        if (temp < 18) return '#0088cc'; // Cold
        if (temp < 22) return '#4caf50'; // Comfortable
        if (temp < 25) return '#ffc107'; // Warm
        return '#f44336'; // Hot
    };
    
    // Update display rules based on temperature
    data.locations.forEach(item => {
        const color = getTemperatureColor(item.value);
        
        mapsIndoorsInstance.setDisplayRule(item.locationId, {
            polygonVisible: true,
            polygonFillColor: color,
            polygonFillOpacity: 0.5,
            polygonStrokeColor: color,
            polygonStrokeOpacity: 0.8,
            polygonStrokeWidth: 1,
            zoomFrom: 16
        });
        
        // Update tooltip content
        mapsIndoorsInstance.setLocationTooltipOptions(item.locationId, {
            content: `
                <div style="padding: 8px;">
                    <div style="font-weight: bold;">${item.name}</div>
                    <div>Temperature: ${item.value}°C</div>
                </div>
            `
        });
    });
}

// Update room occupancy visualization
function updateOccupancyData(data) {
    if (!data.locations || !Array.isArray(data.locations)) return;
    
    // Occupancy color scale (based on percentage of capacity)
    const getOccupancyColor = (count, capacity) => {
        const percentage = capacity ? (count / capacity) * 100 : 0;
        
        if (percentage < 25) return '#4caf50'; // Low occupancy
        if (percentage < 75) return '#ffc107'; // Medium occupancy
        return '#f44336'; // High occupancy
    };
    
    // Update display rules based on occupancy
    data.locations.forEach(item => {
        const color = getOccupancyColor(item.count, item.capacity);
        
        mapsIndoorsInstance.setDisplayRule(item.locationId, {
            polygonVisible: true,
            polygonFillColor: color,
            polygonFillOpacity: item.count ? 0.5 : 0.1, // Lower opacity for empty rooms
            polygonStrokeColor: color,
            polygonStrokeOpacity: 0.8,
            polygonStrokeWidth: 1,
            zoomFrom: 16
        });
    });
}
Accessibility Considerations
When implementing MapsIndoors, it's important to ensure your application is accessible to all users:

javascript
// Enhance accessibility for MapsIndoors
function enhanceAccessibility(mapsIndoorsInstance) {
    // Add accessibility attributes to map container
    const mapContainer = document.getElementById('map');
    mapContainer.setAttribute('role', 'application');
    mapContainer.setAttribute('aria-label', 'Interactive indoor map');
    
    // Create a screen reader friendly summary for locations
    mapsIndoorsInstance.addListener('click', (event) => {
        if (event && event.id) {
            // Get location details
            mapsindoors.services.LocationsService.getLocation(event.id)
                .then(location => {
                    if (location) {
                        const a11yInfo = getAccessibleLocationInfo(location);
                        announceToScreenReader(a11yInfo);
                    }
                });
        }
    });
    
    // Create accessible route directions
    const directionsService = new mapsindoors.services.DirectionsService();
    const directionsRenderer = new mapsindoors.directions.DirectionsRenderer({
        mapsIndoors: mapsIndoorsInstance
    });
    
    // When a route is calculated, create accessible directions
    directionsService.addListener('route_changed', (route) => {
        if (route) {
            const a11yDirections = getAccessibleDirections(route);
            
            // Update ARIA live region with directions
            document.getElementById('directions-a11y').textContent = a11yDirections;
        }
    });
}

// Create screen reader friendly location information
function getAccessibleLocationInfo(location) {
    const props = location.properties;
    
    let info = `${props.name}, ${props.type || 'Location'}`;
    
    if (props.floor !== undefined) {
        info += `, Floor ${props.floor}`;
    }
    
    if (props.description) {
        info += `. ${props.description}`;
    }
    
    return info;
}

// Announce information to screen readers
function announceToScreenReader(text) {
    // Create or get ARIA live region
    let ariaLive = document.getElementById('aria-live-region');
    
    if (!ariaLive) {
        ariaLive = document.createElement('div');
        ariaLive.id = 'aria-live-region';
        ariaLive.className = 'sr-only';
        ariaLive.setAttribute('aria-live', 'polite');
        ariaLive.setAttribute('aria-atomic', 'true');
        document.body.appendChild(ariaLive);
        
        // Add CSS for screen reader only
        const style = document.createElement('style');
        style.textContent = `
            .sr-only {
                position: absolute;
                width: 1px;
                height: 1px;
                padding: 0;
                margin: -1px;
                overflow: hidden;
                clip: rect(0, 0, 0, 0);
                white-space: nowrap;
                border: 0;
            }
        `;
        document.head.appendChild(style);
    }
    
    ariaLive.textContent = text;
}

// Create accessible route directions
function getAccessibleDirections(route) {
    if (!route || !route.legs) return '';
    
    let directions = 'Route directions: ';
    
    route.legs.forEach((leg, legIndex) => {
        if (leg.steps) {
            leg.steps.forEach((step, stepIndex) => {
                directions += `Step ${legIndex + 1}.${stepIndex + 1}: `;
                
                // Convert html instructions to plain text
                if (step.html_instructions) {
                    const div = document.createElement('div');
                    div.innerHTML = step.html_instructions;
                    directions += div.textContent;
                } else {
                    directions += step.instruction || 'Continue';
                }
                
                if (step.distance && step.distance.text) {
                    directions += ` for ${step.distance.text}`;
                }
                
                directions += '. ';
            });
        }
    });
    
    return directions;
}
Testing and Deployment
To ensure your MapsIndoors implementation works reliably, follow these testing and deployment practices:

javascript
// Testing utilities for MapsIndoors
function mapsIndoorsTesting() {
    // Test initialization
    function testInitialization() {
        return new Promise((resolve, reject) => {
            try {
                // Initialize with test parameters
                const mapViewOptions = {
                    accessToken: 'YOUR_MAPBOX_TOKEN',
                    element: document.getElementById('map'),
                    center: { lat: 30.3603212, lng: -97.7422623 },
                    zoom: 20,
                };
                
                const mapViewInstance = new mapsindoors.mapView.MapboxV3View(mapViewOptions);
                const mapsIndoorsInstance = new mapsindoors.MapsIndoors({
                    mapView: mapViewInstance,
                });
                
                // Add ready listener
                mapsIndoorsInstance.addListener('ready', () => {
                    console.log('MapsIndoors initialized successfully');
                    resolve(mapsIndoorsInstance);
                });
                
                // Add error listener
                mapsIndoorsInstance.addListener('error', (error) => {
                    console.error('MapsIndoors initialization failed:', error);
                    reject(error);
                });
                
                // Set timeout for initialization
                setTimeout(() => {
                    reject(new Error('MapsIndoors initialization timed out'));
                }, 10000);
            } catch (error) {
                reject(error);
            }
        });
    }
    
    // Test API connectivity
    async function testAPIConnectivity() {
        try {
            // Test LocationsService
            const locations = await mapsindoors.services.LocationsService.getLocations({
                take: 1
            });
            
            if (!locations || locations.length === 0) {
                throw new Error('Failed to get locations');
            }
            
            console.log('LocationsService test passed');
            
            // Test DirectionsService
            const directionsService = new mapsindoors.services.DirectionsService();
            const origin = locations[0].properties.anchor.coordinates;
            
            const route = await directionsService.getRoute({
                origin: {
                    lat: origin[1],
                    lng: origin[0],
                    floor: locations[0].properties.floor
                },
                destination: {
                    lat: origin[1] + 0.0001,
                    lng: origin[0] + 0.0001,
                    floor: locations[0].properties.floor
                }
            });
            
            if (!route) {
                throw new Error('Failed to get route');
            }
            
            console.log('DirectionsService test passed');
            
            return true;
        } catch (error) {
            console.error('API connectivity test failed:', error);
            return false;
        }
    }
    
    // Return testing utilities
    return {
        testInitialization,
        testAPIConnectivity
    };
}

// Production deployment checklist
function productionDeploymentChecklist() {
    const checks = [
        {
            name: 'API Key Configuration',
            check: () => {
                // Check if API keys are properly configured
                const apiKey = document.querySelector('script[src*="mapsindoors"]')
                    ?.src.match(/apikey=([^&]+)/)?.[1];
                
                return !!apiKey;
            }
        },
        {
            name: 'Error Handling',
            check: () => {
                // Check if global error handling is in place
                return typeof window.onerror === 'function';
            }
        },
        {
            name: 'Performance',
            check: () => {
                // Check if performance monitoring is in place
                return typeof window.performance !== 'undefined' && 
                       typeof window.performance.mark === 'function';
            }
        },
        {
            name: 'Offline Support',
            check: () => {
                // Check if service worker is registered
                return 'serviceWorker' in navigator && 
                       navigator.serviceWorker.controller !== null;
            }
        },
        {
            name: 'Accessibility',
            check: () => {
                // Check for ARIA attributes
                const mapElement = document.getElementById('map');
                return mapElement && mapElement.getAttribute('role') === 'application';
            }
        }
    ];
    
    // Run all checks
    const results = checks.map(item => ({
        name: item.name,
        passed: item.check()
    }));
    
    // Log results
    console.table(results);
    
    // Return overall result
    return results.every(result => result.passed);
}
Final Thoughts
MapsIndoors provides a powerful foundation for building sophisticated indoor mapping applications. This guide has covered the key aspects of working with the SDK, but there's always more to explore. As you develop your application, remember to:

Start with a clear understanding of your use case and user needs
Implement features incrementally, testing each step
Pay attention to performance and user experience
Leverage the full capabilities of both MapsIndoors and Mapbox
Consider accessibility from the beginning of your development
By following these guidelines and using the code examples provided, you'll be well-equipped to create successful MapsIndoors implementations that deliver real value to your users.

Remember that the MapsIndoors team also provides documentation, support, and professional services if you need additional help with your implementation.

Good luck with your MapsIndoors project!














